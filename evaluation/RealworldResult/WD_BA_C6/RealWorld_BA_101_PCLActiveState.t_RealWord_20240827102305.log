[2024-27-08 10:23:05 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827102305)

**Timestamp**: 20240827102305

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}


**project_name**: RealWorld_BA_101_PCLActiveState.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLActiveState.t_RealWord_20240827102305.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 10:23:06 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();\n        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();\n\n        // Checking out what are the prices\n        log_named_int('Borrow Asset Price', _borrowAssetPrice);\n        log_named_int('Collateral Asset Price', _collateralAssetPrice);\n\n        // Check the prices of the borrowAsset and collateralAsset are non-zero\n        assertGt(_borrowAssetPrice, 0);\n        assertGt(_collateralAssetPrice, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with price fluctuations\n    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral decreases if collateral asset price decreases\n    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases\n    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral increases if collateral asset price increases\n    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases\n    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4: Withdraw collateral reverts if collateral asset price decreases\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.1: Withdraw collateral reverts if borrow asset price increases\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.2: Withdraw collateral works if collateral asset price increases\n    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral works if borrow asset price decreases\n    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 6: Required collateral decreases if collateral asset price increases\n    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.1: Required collateral increases if borrow asset price increases\n    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.2: Required collateral increases if collateral asset price decreases\n    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.3: Required collateral decreases if borrow asset price decreases\n    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0\n    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0\n    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7: Collateral ratio decreases if collateral asset price decreases\n    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.1: Collateral ratio decreases if borrow asset price increases\n    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.2: Collateral ratio increases if collateral asset price increases\n    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.3: Collateral ratio increases if borrow asset price decreases\n    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0\n    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0\n    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 10: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated\n    function test_lendersCanOrCannotLiquidate(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Relative price fluctuations\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(\n            10**_decimals\n        );\n\n        if (_currentCollateralRatio &lt; request.collateralRatio) {\n            // assert liquidated\n            _lender0.liquidate(requestId, false);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            // asset not liquidated\n            try _lender0.liquidate(requestId, _withdraw) {\n                revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:L3');\n            }\n        }\n    }\n\n    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 12.2: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)\n        public\n    {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 13: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + request.duration / 2);\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));\n        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 14: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 15.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 16: Borrowable amount decreases if collateral asset price decreases\n    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.1: Borrowable amount decreases if borrow asset price increases\n    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.2: Borrowable amount increases if collateral asset price increases\n    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.3: Borrowable amount increases if borrow asset price decreases\n    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0\n    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0\n    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 17: Borrower can repay\n    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        vm.warp(block.timestamp + 10 days);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertEq(_currentDebt, 0); // Since nothing was borrowed\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertEq(_borrowable, 0); // Since collateral was not deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        vm.warp(block.timestamp + 12 days);\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR2, uint256(-1));\n            assertGt(_currentCR2, request.collateralRatio);\n\n            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);\n\n            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR3, _currentCR2);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertGt(_currentDebt, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertGe(_borrowable, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertGt(_totalCollateral, 0);\n        }\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertGt(_interestAccrued, 0); // Since borrower did borrow\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:06 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:06 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 10:23:10 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:23:10 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 31226
completion_tokens: 1
total_tokens: 31227
cost: $-1.000000


[2024-27-08 10:23:10 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Let's

[2024-27-08 10:23:11 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n    function setUp() public virtual override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n    }\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();\n        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();\n        // Checking out what are the prices\n        log_named_int(\'Borrow Asset Price\', _borrowAssetPrice);\n        log_named_int(\'Collateral Asset Price\', _collateralAssetPrice);\n        // Check the prices of the borrowAsset and collateralAsset are non-zero\n        assertGt(_borrowAssetPrice, 0);\n        assertGt(_collateralAssetPrice, 0);\n    }\n    // Test 1: An active PCL cannot be started even with price fluctuations\n    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.start(requestId) {\n            revert(\'Cannot start an Active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n    // Test 3: Withdrawable collateral decreases if collateral asset price decreases\n    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases\n    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.2: Withdrawable collateral increases if collateral asset price increases\n    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases\n    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 4: Withdraw collateral reverts if collateral asset price decreases\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    // Test 4.1: Withdraw collateral reverts if borrow asset price increases\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    // Test 4.2: Withdraw collateral works if collateral asset price increases\n    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.3: Withdraw collateral works if borrow asset price decreases\n    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n    }\n    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        // Now let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.close(requestId) {\n            revert(\'Cannot close PCL when principal != 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    // Test 6: Required collateral decreases if collateral asset price increases\n    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.1: Required collateral increases if borrow asset price increases\n    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.2: Required collateral increases if collateral asset price decreases\n    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.3: Required collateral decreases if borrow asset price decreases\n    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0\n    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert(\'Required collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0\n    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert(\'Required collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 7: Collateral ratio decreases if collateral asset price decreases\n    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.1: Collateral ratio decreases if borrow asset price increases\n    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.2: Collateral ratio increases if collateral asset price increases\n    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.3: Collateral ratio increases if borrow asset price decreases\n    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0\n    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0\n    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try _lender0.withdrawLiquidation(requestId) {\n            revert(\'Cannot withdraw liquidation from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try _lender0.withdrawLiquidity(requestId) {\n            revert(\'Cannot withdraw liquidity from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    // Test 10: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert(\'Cannot liquidate an Active PCL with principal == 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated\n    function test_lendersCanOrCannotLiquidate(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Relative price fluctuations\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(\n            10_decimals\n        );\n        if (_currentCollateralRatio &lt; request.collateralRatio) {\n            // assert liquidated\n            _lender0.liquidate(requestId, false);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            // asset not liquidated\n            try _lender0.liquidate(requestId, _withdraw) {\n                revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:L3\');\n            }\n        }\n    }\n    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n    // Test 12.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n    // Test 12.2: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)\n        public\n    {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 13: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        vm.warp(block.timestamp + request.duration / 2);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));\n        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));\n        lender0.withdrawInterest(requestId);\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        lender1.withdrawInterest(requestId);\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n    // Test 14: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 15.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 16: Borrowable amount decreases if collateral asset price decreases\n    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.1: Borrowable amount decreases if borrow asset price increases\n    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.2: Borrowable amount increases if collateral asset price increases\n    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.3: Borrowable amount increases if borrow asset price decreases\n    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0\n    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert(\'Borrowable amount should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0\n    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert(\'Borrowable amount should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 17: Borrower can repay\n    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        vm.warp(block.timestamp + 10 days);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertEq(_currentDebt, 0); // Since nothing was borrowed\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertEq(_borrowable, 0); // Since collateral was not deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        vm.warp(block.timestamp + 12 days);\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR2, uint256(-1));\n            assertGt(_currentCR2, request.collateralRatio);\n            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);\n            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR3, _currentCR2);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertGt(_currentDebt, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertGe(_borrowable, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertGt(_totalCollateral, 0);\n        }\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertGt(_interestAccrued, 0); // Since borrower did borrow\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n    function setUp() public virtual override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n    }\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();\n        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();\n        // Checking out what are the prices\n        log_named_int(\'Borrow Asset Price\', _borrowAssetPrice);\n        log_named_int(\'Collateral Asset Price\', _collateralAssetPrice);\n        // Check the prices of the borrowAsset and collateralAsset are non-zero\n        assertGt(_borrowAssetPrice, 0);\n        assertGt(_collateralAssetPrice, 0);\n    }\n    // Test 1: An active PCL cannot be started even with price fluctuations\n    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.start(requestId) {\n            revert(\'Cannot start an Active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n    // Test 3: Withdrawable collateral decreases if collateral asset price decreases\n    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases\n    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.2: Withdrawable collateral increases if collateral asset price increases\n    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases\n    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 4: Withdraw collateral reverts if collateral asset price decreases\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    // Test 4.1: Withdraw collateral reverts if borrow asset price increases\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    // Test 4.2: Withdraw collateral works if collateral asset price increases\n    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.3: Withdraw collateral works if borrow asset price decreases\n    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n    }\n    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        // Now let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.close(requestId) {\n            revert(\'Cannot close PCL when principal != 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    // Test 6: Required collateral decreases if collateral asset price increases\n    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.1: Required collateral increases if borrow asset price increases\n    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.2: Required collateral increases if collateral asset price decreases\n    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.3: Required collateral decreases if borrow asset price decreases\n    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0\n    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert(\'Required collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0\n    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert(\'Required collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 7: Collateral ratio decreases if collateral asset price decreases\n    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.1: Collateral ratio decreases if borrow asset price increases\n    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.2: Collateral ratio increases if collateral asset price increases\n    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.3: Collateral ratio increases if borrow asset price decreases\n    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0\n    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0\n    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try _lender0.withdrawLiquidation(requestId) {\n            revert(\'Cannot withdraw liquidation from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try _lender0.withdrawLiquidity(requestId) {\n            revert(\'Cannot withdraw liquidity from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    // Test 10: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert(\'Cannot liquidate an Active PCL with principal == 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated\n    function test_lendersCanOrCannotLiquidate(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Relative price fluctuations\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(\n            10_decimals\n        );\n        if (_currentCollateralRatio &lt; request.collateralRatio) {\n            // assert liquidated\n            _lender0.liquidate(requestId, false);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            // asset not liquidated\n            try _lender0.liquidate(requestId, _withdraw) {\n                revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n            } catch Error(string memory reason) {\n                assertEq(reason, \'PCL:L3\');\n            }\n        }\n    }\n    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n    // Test 12.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n    // Test 12.2: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)\n        public\n    {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 13: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        vm.warp(block.timestamp + request.duration / 2);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));\n        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));\n        lender0.withdrawInterest(requestId);\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        lender1.withdrawInterest(requestId);\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n    // Test 14: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 15.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 16: Borrowable amount decreases if collateral asset price decreases\n    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.1: Borrowable amount decreases if borrow asset price increases\n    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.2: Borrowable amount increases if collateral asset price increases\n    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.3: Borrowable amount increases if borrow asset price decreases\n    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0\n    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert(\'Borrowable amount should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0\n    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert(\'Borrowable amount should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PO:GLP1\');\n        }\n    }\n    // Test 17: Borrower can repay\n    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        vm.warp(block.timestamp + 10 days);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertEq(_currentDebt, 0); // Since nothing was borrowed\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertEq(_borrowable, 0); // Since collateral was not deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        vm.warp(block.timestamp + 12 days);\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR2, uint256(-1));\n            assertGt(_currentCR2, request.collateralRatio);\n            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);\n            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR3, _currentCR2);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertGt(_currentDebt, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertGe(_borrowable, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertGt(_totalCollateral, 0);\n        }\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertGt(_interestAccrued, 0); // Since borrower did borrow\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:11 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:11 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    function setUp() public virtual override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));
        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }
    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();
        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);
        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }
    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }
    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertGt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertLt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertLt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertGt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );
        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }
    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }
    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }
    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);
        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }
    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        vm.warp(block.timestamp + request.duration / 2);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));
        lender0.withdrawInterest(requestId);
        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }
    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertGt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertGt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }
    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        vm.warp(block.timestamp + 12 days);
        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);
            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);
            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    function setUp() public virtual override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));
        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }
    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();
        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);
        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }
    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }
    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertGt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertLt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertLt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertGt(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );
        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }
    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }
    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }
    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);
        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }
    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        vm.warp(block.timestamp + request.duration / 2);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));
        lender0.withdrawInterest(requestId);
        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }
    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertGt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertGt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }
    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }
    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        vm.warp(block.timestamp + 12 days);
        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);
            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);
            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 10:23:16 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:23:16 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 46894
completion_tokens: 1
total_tokens: 46895
cost: $-1.000000


[2024-27-08 10:23:16 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Security

[2024-27-08 10:23:16 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 10:23:16 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 10:23:16 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 10:23:17 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();\n        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();\n\n        // Checking out what are the prices\n        log_named_int('Borrow Asset Price', _borrowAssetPrice);\n        log_named_int('Collateral Asset Price', _collateralAssetPrice);\n\n        // Check the prices of the borrowAsset and collateralAsset are non-zero\n        assertGt(_borrowAssetPrice, 0);\n        assertGt(_collateralAssetPrice, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with price fluctuations\n    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral decreases if collateral asset price decreases\n    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases\n    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral increases if collateral asset price increases\n    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases\n    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4: Withdraw collateral reverts if collateral asset price decreases\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.1: Withdraw collateral reverts if borrow asset price increases\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.2: Withdraw collateral works if collateral asset price increases\n    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral works if borrow asset price decreases\n    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 6: Required collateral decreases if collateral asset price increases\n    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.1: Required collateral increases if borrow asset price increases\n    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.2: Required collateral increases if collateral asset price decreases\n    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.3: Required collateral decreases if borrow asset price decreases\n    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0\n    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0\n    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7: Collateral ratio decreases if collateral asset price decreases\n    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.1: Collateral ratio decreases if borrow asset price increases\n    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.2: Collateral ratio increases if collateral asset price increases\n    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.3: Collateral ratio increases if borrow asset price decreases\n    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0\n    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0\n    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 10: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated\n    function test_lendersCanOrCannotLiquidate(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Relative price fluctuations\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(\n            10**_decimals\n        );\n\n        if (_currentCollateralRatio &lt; request.collateralRatio) {\n            // assert liquidated\n            _lender0.liquidate(requestId, false);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            // asset not liquidated\n            try _lender0.liquidate(requestId, _withdraw) {\n                revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:L3');\n            }\n        }\n    }\n\n    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 12.2: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)\n        public\n    {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 13: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + request.duration / 2);\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));\n        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 14: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 15.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 16: Borrowable amount decreases if collateral asset price decreases\n    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.1: Borrowable amount decreases if borrow asset price increases\n    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.2: Borrowable amount increases if collateral asset price increases\n    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.3: Borrowable amount increases if borrow asset price decreases\n    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0\n    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0\n    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 17: Borrower can repay\n    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        vm.warp(block.timestamp + 10 days);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertEq(_currentDebt, 0); // Since nothing was borrowed\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertEq(_borrowable, 0); // Since collateral was not deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        vm.warp(block.timestamp + 12 days);\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR2, uint256(-1));\n            assertGt(_currentCR2, request.collateralRatio);\n\n            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);\n\n            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR3, _currentCR2);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertGt(_currentDebt, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertGe(_borrowable, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertGt(_totalCollateral, 0);\n        }\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertGt(_interestAccrued, 0); // Since borrower did borrow\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:17 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:17 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 10:23:20 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:23:20 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 31217
completion_tokens: 1
total_tokens: 31218
cost: $-1.000000


[2024-27-08 10:23:20 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

###

[2024-27-08 10:23:20 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 10:23:20 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 10:23:20 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:20 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:20 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 10:23:35 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:23:35 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15668
completion_tokens: 697
total_tokens: 16365
cost: $-1.000000


[2024-27-08 10:23:35 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Based on the provided Solidity smart contract code and its analysis, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or change state variables could be susceptible to reentrancy attacks, especially in scenarios where external calls are made (e.g., transferring tokens).

2. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, it is crucial to ensure that all arithmetic operations are protected against overflow and underflow. Any future changes or manual arithmetic operations could introduce vulnerabilities if not handled correctly.

3. **Access Control Issues**:
   - The contract lacks proper access control mechanisms for critical functions. For example, functions that modify the state or sensitive parameters should be restricted to only the owner or authorized users.

4. **Price Manipulation**:
   - The reliance on external price oracles (like MockV3Aggregator) without proper validation could lead to price manipulation attacks. If an attacker can influence the price feed, they could exploit the contract's logic to their advantage.

5. **Lack of Input Validation**:
   - Functions that accept user inputs (like amounts for deposits or withdrawals) do not have sufficient validation checks. This could lead to unexpected behaviors or exploitation if invalid data is provided.

6. **Potential for Denial of Service (DoS)**:
   - Certain functions could be vulnerable to DoS attacks, especially if they depend on external calls that may fail or revert. This could lock funds or halt operations within the contract.

7. **Gas Limit Issues**:
   - Some functions may consume excessive gas, especially those that involve loops or complex calculations. This could lead to failures in transactions due to exceeding the gas limit.

8. **Insufficient Testing and Coverage**:
   - The contract has a comprehensive set of tests, but it is essential to ensure that all edge cases and potential attack vectors are covered. Lack of thorough testing could lead to undiscovered vulnerabilities.

### Comprehensive Analysis Report

The analysis of the provided Solidity smart contract reveals several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing issues include the lack of reentrancy protection, which could allow attackers to manipulate contract state during external calls. Additionally, while SafeMath is employed, the reliance on it must be consistent throughout the contract to prevent integer overflow and underflow.

Access control mechanisms are insufficient, which could allow unauthorized users to execute critical functions, leading to unauthorized changes in contract state or funds. The contract's dependence on external price oracles without validation poses a risk of price manipulation, which could be exploited to gain undue advantages in borrowing or liquidation scenarios.

Input validation is another area of concern, as the absence of checks could lead to unexpected behaviors or exploitation through invalid inputs. Furthermore, potential Denial of Service (DoS) vulnerabilities could arise from external calls that fail, locking funds or halting contract operations.

Gas limit issues must also be addressed, as functions that consume excessive gas could lead to transaction failures. Lastly, while the contract has a robust testing framework, it is crucial to ensure that all edge cases are covered to prevent undiscovered vulnerabilities.

In conclusion, it is recommended to implement the following measures:
- Introduce reentrancy guards on critical functions.
- Ensure consistent use of SafeMath for all arithmetic operations.
- Implement strict access control for sensitive functions.


[2024-27-08 10:23:35 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code and its analysis, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or change state variables could be susceptible to reentrancy attacks, especially in scenarios where external calls are made (e.g., transferring tokens).

2. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, it is crucial to ensure that all arithmetic operations are protected against overflow and underflow. Any future changes or manual arithmetic operations could introduce vulnerabilities if not handled correctly.

3. **Access Control Issues**:
   - The contract lacks proper access control mechanisms for critical functions. For example, functions that modify the state or sensitive parameters should be restricted to only the owner or authorized users.

4. **Price Manipulation**:
   - The reliance on external price oracles (like MockV3Aggregator) without proper validation could lead to price manipulation attacks. If an attacker can influence the price feed, they could exploit the contract's logic to their advantage.

5. **Lack of Input Validation**:
   - Functions that accept user inputs (like amounts for deposits or withdrawals) do not have sufficient validation checks. This could lead to unexpected behaviors or exploitation if invalid data is provided.

6. **Potential for Denial of Service (DoS)**:
   - Certain functions could be vulnerable to DoS attacks, especially if they depend on external calls that may fail or revert. This could lock funds or halt operations within the contract.

7. **Gas Limit Issues**:
   - Some functions may consume excessive gas, especially those that involve loops or complex calculations. This could lead to failures in transactions due to exceeding the gas limit.

8. **Insufficient Testing and Coverage**:
   - The contract has a comprehensive set of tests, but it is essential to ensure that all edge cases and potential attack vectors are covered. Lack of thorough testing could lead to undiscovered vulnerabilities.

### Comprehensive Analysis Report

The analysis of the provided Solidity smart contract reveals several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing issues include the lack of reentrancy protection, which could allow attackers to manipulate contract state during external calls. Additionally, while SafeMath is employed, the reliance on it must be consistent throughout the contract to prevent integer overflow and underflow.

Access control mechanisms are insufficient, which could allow unauthorized users to execute critical functions, leading to unauthorized changes in contract state or funds. The contract's dependence on external price oracles without validation poses a risk of price manipulation, which could be exploited to gain undue advantages in borrowing or liquidation scenarios.

Input validation is another area of concern, as the absence of checks could lead to unexpected behaviors or exploitation through invalid inputs. Furthermore, potential Denial of Service (DoS) vulnerabilities could arise from external calls that fail, locking funds or halting contract operations.

Gas limit issues must also be addressed, as functions that consume excessive gas could lead to transaction failures. Lastly, while the contract has a robust testing framework, it is crucial to ensure that all edge cases are covered to prevent undiscovered vulnerabilities.

In conclusion, it is recommended to implement the following measures:
- Introduce reentrancy guards on critical functions.
- Ensure consistent use of SafeMath for all arithmetic operations.
- Implement strict access control for sensitive functions.


[2024-27-08 10:23:35 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 10:23:35 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();\n        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();\n\n        // Checking out what are the prices\n        log_named_int('Borrow Asset Price', _borrowAssetPrice);\n        log_named_int('Collateral Asset Price', _collateralAssetPrice);\n\n        // Check the prices of the borrowAsset and collateralAsset are non-zero\n        assertGt(_borrowAssetPrice, 0);\n        assertGt(_collateralAssetPrice, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with price fluctuations\n    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral decreases if collateral asset price decreases\n    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases\n    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral increases if collateral asset price increases\n    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases\n    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4: Withdraw collateral reverts if collateral asset price decreases\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.1: Withdraw collateral reverts if borrow asset price increases\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.2: Withdraw collateral works if collateral asset price increases\n    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral works if borrow asset price decreases\n    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 6: Required collateral decreases if collateral asset price increases\n    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.1: Required collateral increases if borrow asset price increases\n    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.2: Required collateral increases if collateral asset price decreases\n    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.3: Required collateral decreases if borrow asset price decreases\n    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0\n    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0\n    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7: Collateral ratio decreases if collateral asset price decreases\n    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.1: Collateral ratio decreases if borrow asset price increases\n    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.2: Collateral ratio increases if collateral asset price increases\n    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.3: Collateral ratio increases if borrow asset price decreases\n    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0\n    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0\n    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 10: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated\n    function test_lendersCanOrCannotLiquidate(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Relative price fluctuations\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(\n            10**_decimals\n        );\n\n        if (_currentCollateralRatio &lt; request.collateralRatio) {\n            // assert liquidated\n            _lender0.liquidate(requestId, false);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            // asset not liquidated\n            try _lender0.liquidate(requestId, _withdraw) {\n                revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:L3');\n            }\n        }\n    }\n\n    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 12.2: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)\n        public\n    {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 13: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + request.duration / 2);\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));\n        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 14: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 15.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 16: Borrowable amount decreases if collateral asset price decreases\n    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.1: Borrowable amount decreases if borrow asset price increases\n    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.2: Borrowable amount increases if collateral asset price increases\n    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.3: Borrowable amount increases if borrow asset price decreases\n    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0\n    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0\n    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 17: Borrower can repay\n    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        vm.warp(block.timestamp + 10 days);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertEq(_currentDebt, 0); // Since nothing was borrowed\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertEq(_borrowable, 0); // Since collateral was not deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        vm.warp(block.timestamp + 12 days);\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR2, uint256(-1));\n            assertGt(_currentCR2, request.collateralRatio);\n\n            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);\n\n            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR3, _currentCR2);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertGt(_currentDebt, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertGe(_borrowable, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertGt(_totalCollateral, 0);\n        }\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertGt(_interestAccrued, 0); // Since borrower did borrow\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:35 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:35 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 10:23:40 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:23:40 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 31217
completion_tokens: 1
total_tokens: 31218
cost: $-1.000000


[2024-27-08 10:23:40 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

###

[2024-27-08 10:23:40 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 10:23:40 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 10:23:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:40 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 10:23:51 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:23:51 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15668
completion_tokens: 680
total_tokens: 16348
cost: $-1.000000


[2024-27-08 10:23:51 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Based on the provided smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrancy attacks during critical state changes, particularly in functions that involve transferring tokens or updating balances.

2. **Arithmetic Overflow/Underflow**:
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to unexpected behavior if not properly handled, especially when dealing with user inputs.

3. **Access Control Issues**:
   - Certain functions may lack proper access control, allowing unauthorized users to execute sensitive operations. For instance, functions that modify the state or transfer assets should be restricted to specific roles (e.g., admin or borrower).

4. **Price Manipulation**:
   - The reliance on external price oracles without sufficient validation or fallback mechanisms could expose the contract to price manipulation attacks. If an attacker can influence the price feeds, they may exploit this to their advantage.

5. **Gas Limit and Loops**:
   - Functions that involve loops or extensive computations may exceed gas limits, leading to failed transactions. This is particularly concerning in scenarios where the number of lenders or collateral amounts can vary significantly.

6. **Lack of Event Emissions**:
   - Important state changes and actions (e.g., deposits, withdrawals, and transfers) may not emit events, making it difficult to track contract activity and audit trails.

7. **Inadequate Testing for Edge Cases**:
   - The testing framework may not cover all edge cases, particularly in scenarios involving extreme values or unexpected user behavior, which could lead to unexpected contract states.

8. **Potential for Denial of Service (DoS)**:
   - Certain functions may be vulnerable to DoS attacks if they rely on external calls or if they can be blocked by malicious actors, preventing legitimate users from executing necessary actions.

### Comprehensive Analysis Report:

The analysis of the smart contract has revealed several critical security vulnerabilities that could potentially compromise the integrity and functionality of the contract. The presence of reentrancy vulnerabilities, arithmetic overflow risks, and inadequate access control measures are particularly concerning, as they could lead to unauthorized access and manipulation of funds.

Moreover, the reliance on external price oracles without sufficient safeguards against manipulation poses a significant risk, especially in a volatile market environment. The potential for gas limit issues and the lack of event emissions further complicate the contract's reliability and transparency.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Utilize mutexes or checks-effects-interactions patterns to prevent reentrancy attacks.
- **Enhanced Access Control**: Implement role-based access control to restrict sensitive functions to authorized users only.
- **Price Validation**: Introduce mechanisms to validate price feeds and implement fallback strategies in case of discrepancies.
- **Thorough Testing**: Expand the testing suite to cover edge cases and ensure comprehensive coverage of all functionalities.
- **Event Logging**: Ensure that all critical actions emit events for better tracking and auditing.

In conclusion, while the contract demonstrates a solid foundation, addressing the identified vulnerabilities is crucial to ensuring its security and reliability in a production environment. Regular audits and updates should be conducted to adapt to evolving security threats and best practices in smart contract development.

[2024-27-08 10:23:51 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement checks to prevent reentrancy attacks during critical state changes, particularly in functions that involve transferring tokens or updating balances.

2. **Arithmetic Overflow/Underflow**:
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to unexpected behavior if not properly handled, especially when dealing with user inputs.

3. **Access Control Issues**:
   - Certain functions may lack proper access control, allowing unauthorized users to execute sensitive operations. For instance, functions that modify the state or transfer assets should be restricted to specific roles (e.g., admin or borrower).

4. **Price Manipulation**:
   - The reliance on external price oracles without sufficient validation or fallback mechanisms could expose the contract to price manipulation attacks. If an attacker can influence the price feeds, they may exploit this to their advantage.

5. **Gas Limit and Loops**:
   - Functions that involve loops or extensive computations may exceed gas limits, leading to failed transactions. This is particularly concerning in scenarios where the number of lenders or collateral amounts can vary significantly.

6. **Lack of Event Emissions**:
   - Important state changes and actions (e.g., deposits, withdrawals, and transfers) may not emit events, making it difficult to track contract activity and audit trails.

7. **Inadequate Testing for Edge Cases**:
   - The testing framework may not cover all edge cases, particularly in scenarios involving extreme values or unexpected user behavior, which could lead to unexpected contract states.

8. **Potential for Denial of Service (DoS)**:
   - Certain functions may be vulnerable to DoS attacks if they rely on external calls or if they can be blocked by malicious actors, preventing legitimate users from executing necessary actions.

### Comprehensive Analysis Report:

The analysis of the smart contract has revealed several critical security vulnerabilities that could potentially compromise the integrity and functionality of the contract. The presence of reentrancy vulnerabilities, arithmetic overflow risks, and inadequate access control measures are particularly concerning, as they could lead to unauthorized access and manipulation of funds.

Moreover, the reliance on external price oracles without sufficient safeguards against manipulation poses a significant risk, especially in a volatile market environment. The potential for gas limit issues and the lack of event emissions further complicate the contract's reliability and transparency.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Utilize mutexes or checks-effects-interactions patterns to prevent reentrancy attacks.
- **Enhanced Access Control**: Implement role-based access control to restrict sensitive functions to authorized users only.
- **Price Validation**: Introduce mechanisms to validate price feeds and implement fallback strategies in case of discrepancies.
- **Thorough Testing**: Expand the testing suite to cover edge cases and ensure comprehensive coverage of all functionalities.
- **Event Logging**: Ensure that all critical actions emit events for better tracking and auditing.

In conclusion, while the contract demonstrates a solid foundation, addressing the identified vulnerabilities is crucial to ensuring its security and reliability in a production environment. Regular audits and updates should be conducted to adapt to evolving security threats and best practices in smart contract development.

[2024-27-08 10:23:51 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 10:23:52 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();\n        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();\n\n        // Checking out what are the prices\n        log_named_int('Borrow Asset Price', _borrowAssetPrice);\n        log_named_int('Collateral Asset Price', _collateralAssetPrice);\n\n        // Check the prices of the borrowAsset and collateralAsset are non-zero\n        assertGt(_borrowAssetPrice, 0);\n        assertGt(_collateralAssetPrice, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with price fluctuations\n    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral decreases if collateral asset price decreases\n    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases\n    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral increases if collateral asset price increases\n    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases\n    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4: Withdraw collateral reverts if collateral asset price decreases\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.1: Withdraw collateral reverts if borrow asset price increases\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.2: Withdraw collateral works if collateral asset price increases\n    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral works if borrow asset price decreases\n    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 6: Required collateral decreases if collateral asset price increases\n    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.1: Required collateral increases if borrow asset price increases\n    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.2: Required collateral increases if collateral asset price decreases\n    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.3: Required collateral decreases if borrow asset price decreases\n    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0\n    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0\n    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7: Collateral ratio decreases if collateral asset price decreases\n    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.1: Collateral ratio decreases if borrow asset price increases\n    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.2: Collateral ratio increases if collateral asset price increases\n    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.3: Collateral ratio increases if borrow asset price decreases\n    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0\n    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0\n    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 10: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated\n    function test_lendersCanOrCannotLiquidate(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Relative price fluctuations\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(\n            10**_decimals\n        );\n\n        if (_currentCollateralRatio &lt; request.collateralRatio) {\n            // assert liquidated\n            _lender0.liquidate(requestId, false);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            // asset not liquidated\n            try _lender0.liquidate(requestId, _withdraw) {\n                revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:L3');\n            }\n        }\n    }\n\n    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 12.2: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)\n        public\n    {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 13: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + request.duration / 2);\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));\n        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 14: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 15.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 16: Borrowable amount decreases if collateral asset price decreases\n    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.1: Borrowable amount decreases if borrow asset price increases\n    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.2: Borrowable amount increases if collateral asset price increases\n    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.3: Borrowable amount increases if borrow asset price decreases\n    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0\n    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0\n    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 17: Borrower can repay\n    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        vm.warp(block.timestamp + 10 days);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertEq(_currentDebt, 0); // Since nothing was borrowed\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertEq(_borrowable, 0); // Since collateral was not deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        vm.warp(block.timestamp + 12 days);\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR2, uint256(-1));\n            assertGt(_currentCR2, request.collateralRatio);\n\n            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);\n\n            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR3, _currentCR2);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertGt(_currentDebt, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertGe(_borrowable, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertGt(_totalCollateral, 0);\n        }\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertGt(_interestAccrued, 0); // Since borrower did borrow\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:52 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:52 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 10:23:55 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:23:55 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 31217
completion_tokens: 1
total_tokens: 31218
cost: $-1.000000


[2024-27-08 10:23:55 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

###

[2024-27-08 10:23:55 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 10:23:55 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 10:23:55 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 10:23:55 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:23:55 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 10:24:09 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 10:24:09 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15668
completion_tokens: 674
total_tokens: 16342
cost: $-1.000000


[2024-27-08 10:24:09 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Based on the provided smart contract code and its structure, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer assets or modify state variables, potentially leading to unexpected behaviors or loss of funds.

2. **Arithmetic Overflows/Underflows**:
   - Although the code uses `SafeMath`, it is crucial to ensure that all arithmetic operations are consistently protected against overflows and underflows, especially in critical calculations like collateral ratios and debt calculations.

3. **Access Control Issues**:
   - There may be insufficient access control on functions that modify sensitive state variables or perform critical actions (e.g., terminating a PCL, withdrawing funds). This could allow unauthorized users to execute functions they should not have access to.

4. **Price Manipulation**:
   - The reliance on external price oracles (e.g., `MockV3Aggregator`) without proper validation could expose the contract to price manipulation attacks. If the oracle provides false data, it could lead to incorrect collateral valuations and borrowing limits.

5. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., transferring tokens or iterating through lenders) could run into gas limit issues, especially if the number of lenders is large. This could lead to failed transactions or denial of service.

6. **Lack of Event Emissions**:
   - Important state changes (e.g., collateral deposits, withdrawals, and borrowings) should emit events to provide transparency and allow for easier tracking of contract activity. The absence of events can hinder debugging and monitoring.

7. **Potential for Unchecked External Calls**:
   - The contract makes external calls to other contracts (e.g., transferring tokens). If these contracts are malicious or fail, it could lead to unexpected behaviors. Proper checks and validations should be in place.

8. **Default Values and Initialization**:
   - Certain variables may not be initialized properly, leading to default values being used unintentionally. This can cause logical errors in calculations and contract behavior.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors. The absence of reentrancy guards poses a significant risk, particularly in functions that involve transferring assets. While `SafeMath` is utilized, it is essential to ensure that all arithmetic operations are protected to prevent overflows and underflows.

Access control mechanisms must be thoroughly reviewed to prevent unauthorized access to critical functions. Additionally, the reliance on external price oracles without adequate validation could lead to price manipulation, affecting collateral valuations and borrowing limits.

The potential for gas limit issues in functions with loops should be addressed to avoid denial of service. Furthermore, the lack of event emissions for critical state changes can hinder transparency and monitoring.

Unchecked external calls to other contracts present a risk if those contracts are compromised or fail. Lastly, proper initialization of variables is crucial to avoid logical errors in contract behavior.

In conclusion, it is imperative to conduct a thorough audit of the contract, implement necessary security measures, and ensure best practices are followed to mitigate these vulnerabilities. Regular updates and monitoring of the contract's performance and security posture are also recommended to adapt to evolving threats in the blockchain ecosystem.

[2024-27-08 10:24:09 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and its structure, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer assets or modify state variables, potentially leading to unexpected behaviors or loss of funds.

2. **Arithmetic Overflows/Underflows**:
   - Although the code uses `SafeMath`, it is crucial to ensure that all arithmetic operations are consistently protected against overflows and underflows, especially in critical calculations like collateral ratios and debt calculations.

3. **Access Control Issues**:
   - There may be insufficient access control on functions that modify sensitive state variables or perform critical actions (e.g., terminating a PCL, withdrawing funds). This could allow unauthorized users to execute functions they should not have access to.

4. **Price Manipulation**:
   - The reliance on external price oracles (e.g., `MockV3Aggregator`) without proper validation could expose the contract to price manipulation attacks. If the oracle provides false data, it could lead to incorrect collateral valuations and borrowing limits.

5. **Gas Limit and Loops**:
   - Functions that involve loops (e.g., transferring tokens or iterating through lenders) could run into gas limit issues, especially if the number of lenders is large. This could lead to failed transactions or denial of service.

6. **Lack of Event Emissions**:
   - Important state changes (e.g., collateral deposits, withdrawals, and borrowings) should emit events to provide transparency and allow for easier tracking of contract activity. The absence of events can hinder debugging and monitoring.

7. **Potential for Unchecked External Calls**:
   - The contract makes external calls to other contracts (e.g., transferring tokens). If these contracts are malicious or fail, it could lead to unexpected behaviors. Proper checks and validations should be in place.

8. **Default Values and Initialization**:
   - Certain variables may not be initialized properly, leading to default values being used unintentionally. This can cause logical errors in calculations and contract behavior.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could be exploited by malicious actors. The absence of reentrancy guards poses a significant risk, particularly in functions that involve transferring assets. While `SafeMath` is utilized, it is essential to ensure that all arithmetic operations are protected to prevent overflows and underflows.

Access control mechanisms must be thoroughly reviewed to prevent unauthorized access to critical functions. Additionally, the reliance on external price oracles without adequate validation could lead to price manipulation, affecting collateral valuations and borrowing limits.

The potential for gas limit issues in functions with loops should be addressed to avoid denial of service. Furthermore, the lack of event emissions for critical state changes can hinder transparency and monitoring.

Unchecked external calls to other contracts present a risk if those contracts are compromised or fail. Lastly, proper initialization of variables is crucial to avoid logical errors in contract behavior.

In conclusion, it is imperative to conduct a thorough audit of the contract, implement necessary security measures, and ensure best practices are followed to mitigate these vulnerabilities. Regular updates and monitoring of the contract's performance and security posture are also recommended to adapt to evolving threats in the blockchain ecosystem.

[2024-27-08 10:24:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 100 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = noYieldAddress;\n        request.collateralAssetStrategy = noYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();\n        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();\n\n        // Checking out what are the prices\n        log_named_int('Borrow Asset Price', _borrowAssetPrice);\n        log_named_int('Collateral Asset Price', _collateralAssetPrice);\n\n        // Check the prices of the borrowAsset and collateralAsset are non-zero\n        assertGt(_borrowAssetPrice, 0);\n        assertGt(_collateralAssetPrice, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with price fluctuations\n    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral decreases if collateral asset price decreases\n    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases\n    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral increases if collateral asset price increases\n    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases\n    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0\n    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4: Withdraw collateral reverts if collateral asset price decreases\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.1: Withdraw collateral reverts if borrow asset price increases\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 4.2: Withdraw collateral works if collateral asset price increases\n    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral works if borrow asset price decreases\n    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0\n    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0\n    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 6: Required collateral decreases if collateral asset price increases\n    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.1: Required collateral increases if borrow asset price increases\n    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.2: Required collateral increases if collateral asset price decreases\n    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertLt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.3: Required collateral decreases if borrow asset price decreases\n    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertGt(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0\n    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0\n    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {\n            revert('Required collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7: Collateral ratio decreases if collateral asset price decreases\n    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.1: Collateral ratio decreases if borrow asset price increases\n    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.2: Collateral ratio increases if collateral asset price increases\n    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.3: Collateral ratio increases if borrow asset price decreases\n    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0\n    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0\n    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 10: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated\n    function test_lendersCanOrCannotLiquidate(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed,\n        bool _withdraw\n    ) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Relative price fluctuations\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(\n            10**_decimals\n        );\n\n        if (_currentCollateralRatio &lt; request.collateralRatio) {\n            // assert liquidated\n            _lender0.liquidate(requestId, false);\n            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n        } else {\n            // asset not liquidated\n            try _lender0.liquidate(requestId, _withdraw) {\n                revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n            } catch Error(string memory reason) {\n                assertEq(reason, 'PCL:L3');\n            }\n        }\n    }\n\n    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR\n    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 12.2: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)\n        public\n    {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 13: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + request.duration / 2);\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));\n        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 14: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 15.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 16: Borrowable amount decreases if collateral asset price decreases\n    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.1: Borrowable amount decreases if borrow asset price increases\n    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.2: Borrowable amount increases if collateral asset price increases\n    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.3: Borrowable amount increases if borrow asset price decreases\n    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0\n    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0\n    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PO:GLP1');\n        }\n    }\n\n    // Test 17: Borrower can repay\n    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        vm.warp(block.timestamp + 10 days);\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertEq(_currentDebt, 0); // Since nothing was borrowed\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertEq(_borrowable, 0); // Since collateral was not deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(\n        uint256 _id,\n        uint256 _borrowAssetPriceSeed,\n        uint256 _collateralAssetPriceSeed\n    ) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        vm.warp(block.timestamp + 12 days);\n\n        // 1. calculateCurrentCollateralRatio\n        {\n            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR2, uint256(-1));\n            assertGt(_currentCR2, request.collateralRatio);\n\n            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);\n\n            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n            assertLt(_currentCR3, _currentCR2);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 2. calculatePrincipalWithdrawable\n        {\n            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 3. withdrawableCollateral\n        {\n            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 4. calculateCurrentDebt\n        {\n            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);\n            assertGt(_currentDebt, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 5. calculateBorrowableAmount\n        {\n            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);\n            assertGe(_borrowable, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 6. calculateTotalCollateralTokens\n        {\n            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n            assertGt(_totalCollateral, 0);\n        }\n        // 7. collateralTokensToLiquidate\n        {\n            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n            assertGt(_equivalentCollateral, 0);\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n\n        // 8. calculateInterestAccrued\n        {\n            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);\n            assertGt(_interestAccrued, 0); // Since borrower did borrow\n        }\n        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 10:24:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public virtual override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 100 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = noYieldAddress;     request.collateralAssetStrategy = noYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();     (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();      // Checking out what are the prices     log_named_int('Borrow Asset Price', _borrowAssetPrice);     log_named_int('Collateral Asset Price', _collateralAssetPrice);      // Check the prices of the borrowAsset and collateralAsset are non-zero     assertGt(_borrowAssetPrice, 0);     assertGt(_collateralAssetPrice, 0); }  // Test 1: An active PCL cannot be started even with price fluctuations function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral decreases if collateral asset price decreases function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if borrow asset price increases function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral increases if collateral asset price increases function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral increases if borrow asset price decreases function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0 function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0 function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4: Withdraw collateral reverts if collateral asset price decreases function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.1: Withdraw collateral reverts if borrow asset price increases function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 4.2: Withdraw collateral works if collateral asset price increases function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral works if borrow asset price decreases function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0 function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0 function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 6: Required collateral decreases if collateral asset price increases function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.1: Required collateral increases if borrow asset price increases function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.2: Required collateral increases if collateral asset price decreases function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertLt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.3: Required collateral decreases if borrow asset price decreases function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertGt(_requiredCollateral, _requiredCollateralNew); }  // Test 6.4: Required collateral reverts if borrow asset price decreases to 0 function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 6.5: Required collateral reverts if collateral asset price decreases to 0 function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {         revert('Required collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7: Collateral ratio decreases if collateral asset price decreases function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.1: Collateral ratio decreases if borrow asset price increases function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 7.2: Collateral ratio increases if collateral asset price increases function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.3: Collateral ratio increases if borrow asset price decreases function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0 function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0 function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 10: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated function test_lendersCanOrCannotLiquidate(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed,     bool _withdraw ) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Relative price fluctuations     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(         10**_decimals     );      if (_currentCollateralRatio &lt; request.collateralRatio) {         // assert liquidated         _lender0.liquidate(requestId, false);         assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);     } else {         // asset not liquidated         try _lender0.liquidate(requestId, _withdraw) {             revert('Cannot liquidate an Active PCL with CR &gt;= ICR');         } catch Error(string memory reason) {             assertEq(reason, 'PCL:L3');         }     } }  // Test 10.2: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 10.3: An active PCL can be liquidated if principal != 0 and CR &lt; ICR function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(1);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 12.2: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)     public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 13: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + request.duration / 2);      // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));     uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 14: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 15.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 16: Borrowable amount decreases if collateral asset price decreases function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.1: Borrowable amount decreases if borrow asset price increases function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.2: Borrowable amount increases if collateral asset price increases function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.3: Borrowable amount increases if borrow asset price decreases function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0 function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0 function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'PO:GLP1');     } }  // Test 17: Borrower can repay function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      vm.warp(block.timestamp + 10 days);     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);         assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertEq(_currentDebt, 0); // Since nothing was borrowed     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertEq(_borrowable, 0); // Since collateral was not deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertEq(_totalCollateral, 0); // Since no collateral was deposited     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertEq(_interestAccrued, 0); // Since borrower did not borrow anything     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(     uint256 _id,     uint256 _borrowAssetPriceSeed,     uint256 _collateralAssetPriceSeed ) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      vm.warp(block.timestamp + 12 days);      // 1. calculateCurrentCollateralRatio     {         uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR2, uint256(-1));         assertGt(_currentCR2, request.collateralRatio);          helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);          uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);         assertLt(_currentCR3, _currentCR2);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 2. calculatePrincipalWithdrawable     {         uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));         assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 3. withdrawableCollateral     {         uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);         assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 4. calculateCurrentDebt     {         uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);         assertGt(_currentDebt, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 5. calculateBorrowableAmount     {         uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);         assertGe(_borrowable, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 6. calculateTotalCollateralTokens     {         uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);         assertGt(_totalCollateral, 0);     }     // 7. collateralTokensToLiquidate     {         uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));         assertGt(_equivalentCollateral, 0);     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);      // 8. calculateInterestAccrued     {         uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);         assertGt(_interestAccrued, 0); // Since borrower did borrow     }     helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 10:24:13 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStatePriceOracle is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public virtual override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((5 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 100 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = noYieldAddress;
        request.collateralAssetStrategy = noYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        (, int256 _borrowAssetPrice, , , ) = MockV3Aggregator(borrowAssetAggregatorAddress).latestRoundData();
        (, int256 _collateralAssetPrice, , , ) = MockV3Aggregator(collateralAssetAggregatorAddress).latestRoundData();

        // Checking out what are the prices
        log_named_int('Borrow Asset Price', _borrowAssetPrice);
        log_named_int('Collateral Asset Price', _collateralAssetPrice);

        // Check the prices of the borrowAsset and collateralAsset are non-zero
        assertGt(_borrowAssetPrice, 0);
        assertGt(_collateralAssetPrice, 0);
    }

    // Test 1: An active PCL cannot be started even with price fluctuations
    function test_pclCannotBeStarted(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral decreases if collateral asset price decreases
    function test_withdrawableCollateralDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if borrow asset price increases
    function test_withdrawableCollateralDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral increases if collateral asset price increases
    function test_withdrawableCollateralIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral increases if borrow asset price decreases
    function test_withdrawableCollateralIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.4: Withdrawable collateral reverts if borrow asset price decreases to 0
    function test_withdrawableCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 3.5: Withdrawable collateral reverts if collateral asset price decreases to 0
    function test_withdrawableCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4: Withdraw collateral reverts if collateral asset price decreases
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.1: Withdraw collateral reverts if borrow asset price increases
    function test_withdrawCollateralRevertsIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 4.2: Withdraw collateral works if collateral asset price increases
    function test_withdrawCollateralWorksIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral works if borrow asset price decreases
    function test_withdrawCollateralWorksIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.4: Withdraw collateral reverts if borrow asset price decreases to 0
    function test_withdrawCollateralRevertsIfBorrowAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 4.5: Withdraw collateral reverts if collateral asset price decreases to 0
    function test_withdrawCollateralRevertsIfCollateralAssetPriceDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 5: An active PCL (with principal == 0) can be closed even with price fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 5.1: An active PCL (with principal != 0) cannot be closed even with price fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 6: Required collateral decreases if collateral asset price increases
    function test_requiredCollateralDecreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.1: Required collateral increases if borrow asset price increases
    function test_requiredCollateralIncreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.2: Required collateral increases if collateral asset price decreases
    function test_requiredCollateralIncreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertLt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.3: Required collateral decreases if borrow asset price decreases
    function test_requiredCollateralDecreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertGt(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 6.4: Required collateral reverts if borrow asset price decreases to 0
    function test_requiredCollateralRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 6.5: Required collateral reverts if collateral asset price decreases to 0
    function test_requiredCollateralRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.getRequiredCollateral(requestId, request.borrowLimit / 2) {
            revert('Required collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7: Collateral ratio decreases if collateral asset price decreases
    function test_collateralRatioDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.1: Collateral ratio decreases if borrow asset price increases
    function test_collateralRatioDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.2: Collateral ratio increases if collateral asset price increases
    function test_collateralRatioIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.3: Collateral ratio increases if borrow asset price decreases
    function test_collateralRatioIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 7.4: Collateral ratio reverts if borrow asset price decreases to 0
    function test_collateralRatioRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 7.5: Collateral ratio reverts if collateral asset price decreases to 0
    function test_collateralRatioRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 8: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 9: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 10: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 10.1: An active PCL with principal != 0 can or cannot be liquidated
    function test_lendersCanOrCannotLiquidate(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed,
        bool _withdraw
    ) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Relative price fluctuations
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        uint256 _currentCollateralRatio = pcl.calculateTotalCollateralTokens(requestId).mul(_ratioOfPrices).div(_currentDebt).mul(1e18).div(
            10**_decimals
        );

        if (_currentCollateralRatio < request.collateralRatio) {
            // assert liquidated
            _lender0.liquidate(requestId, false);
            assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
        } else {
            // asset not liquidated
            try _lender0.liquidate(requestId, _withdraw) {
                revert('Cannot liquidate an Active PCL with CR >= ICR');
            } catch Error(string memory reason) {
                assertEq(reason, 'PCL:L3');
            }
        }
    }

    // Test 10.2: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfCollateralAssetPriceDecreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 10.3: An active PCL can be liquidated if principal != 0 and CR < ICR
    function test_lendersCanLiquidateIfBorrowAssetPriceIncreases(uint256 _seed) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(1);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.2: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 12.2: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed)
        public
    {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 12.3: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero(
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == (3 * lender2PoolTokenBalance) / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 13: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + request.duration / 2);

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lender0.getLenderInterest(requestId, address(lender0));
        uint256 lender1InterestOwed = lender1.getLenderInterest(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertEq((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 14: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 15.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 16: Borrowable amount decreases if collateral asset price decreases
    function test_borrowableAmountDecreasesIfCollateralAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.1: Borrowable amount decreases if borrow asset price increases
    function test_borrowableAmountDecreasesIfBorrowAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.2: Borrowable amount increases if collateral asset price increases
    function test_borrowableAmountIncreasesIfCollateralAssetPriceIncreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseAssetPrice(collateralAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.3: Borrowable amount increases if borrow asset price decreases
    function test_borrowableAmountIncreasesIfBorrowAssetPriceDecreases(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPrice(borrowAssetAggregatorAddress, _seed);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 16.4: Borrowable amount reverts if borrow asset price decreases to 0
    function test_borrowableAmountRevertsIfBorrowAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(borrowAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 16.5: Borrowable amount reverts if collateral asset price decreases to 0
    function test_borrowableAmountRevertsIfCollateralAssetPriceDecreasesToZero(uint256 _seed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseAssetPriceToZero(collateralAssetAggregatorAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'PO:GLP1');
        }
    }

    // Test 17: Borrower can repay
    function test_borrowerCanRepay(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        vm.warp(block.timestamp + 10 days);
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
            assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertEq(_currentDebt, 0); // Since nothing was borrowed
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertEq(_borrowable, 0); // Since collateral was not deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertEq(_totalCollateral, 0); // Since no collateral was deposited
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(
        uint256 _id,
        uint256 _borrowAssetPriceSeed,
        uint256 _collateralAssetPriceSeed
    ) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        vm.warp(block.timestamp + 12 days);

        // 1. calculateCurrentCollateralRatio
        {
            uint256 _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR2, uint256(-1));
            assertGt(_currentCR2, request.collateralRatio);

            helper_decreaseAssetPrice(collateralAssetAggregatorAddress, _collateralAssetPriceSeed);

            uint256 _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
            assertLt(_currentCR3, _currentCR2);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 2. calculatePrincipalWithdrawable
        {
            uint256 _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
            assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 3. withdrawableCollateral
        {
            uint256 _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
            assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 4. calculateCurrentDebt
        {
            uint256 _currentDebt = _borrower.calculateCurrentDebt(_id);
            assertGt(_currentDebt, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 5. calculateBorrowableAmount
        {
            uint256 _borrowable = _borrower.calculateBorrowableAmount(_id);
            assertGe(_borrowable, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 6. calculateTotalCollateralTokens
        {
            uint256 _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
            assertGt(_totalCollateral, 0);
        }
        // 7. collateralTokensToLiquidate
        {
            uint256 _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
            assertGt(_equivalentCollateral, 0);
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);

        // 8. calculateInterestAccrued
        {
            uint256 _interestAccrued = _borrower.calculateInterestAccrued(_id);
            assertGt(_interestAccrued, 0); // Since borrower did borrow
        }
        helper_priceChanges(_borrowAssetPriceSeed, _collateralAssetPriceSeed);
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal(uint256 _borrowAssetPriceSeed, uint256 _collateralAssetPriceSeed) public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId, _borrowAssetPriceSeed, _collateralAssetPriceSeed);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

