[2024-27-08 09:18:32 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827091832)

**Timestamp**: 20240827091832

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}


**project_name**: RealWorld_BA_101_PCLActiveState.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLActiveState.t_RealWord_20240827091832.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 09:18:32 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply\n    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly\n    // increase slowly wrt to interest rate of the pcl\n    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);\n\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);\n    }\n\n    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_exchangeRateChanges();\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 10.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);\n    }\n\n    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero\n    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero\n    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly\n    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));\n\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        vm.warp(block.timestamp + 1000);\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + 1000);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Since nothing was borrowed\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since collateral was not deposited\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0); // Since no collateral was deposited\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        assertGt(_currentCR2, request.collateralRatio);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertGt(_currentCR3, _currentCR2);\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertGe(_borrowable, 0);\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Since borrower did borrow\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState() public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:18:32 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:32 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 09:18:36 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:18:36 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30386
completion_tokens: 1
total_tokens: 30387
cost: $-1.000000


[2024-27-08 09:18:36 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Let's

[2024-27-08 09:18:37 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n    function setUp() public override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n    }\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n        // Checking out what are the exchange rates\n        log_named_int(\'Borrow CToken Exchange Rate\', int256(_borrowCTokenExchangeRate));\n        log_named_int(\'Collateral CToken Exchange Rate\', int256(_collateralCTokenExchangeRate));\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n    // Test 1: An active PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n        try borrower.start(requestId) {\n            revert(\'Cannot start an Active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply\n    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly\n    // increase slowly wrt to interest rate of the pcl\n    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10_decimals).div(1e18);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);\n    }\n    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        helper_exchangeRateChanges();\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n    }\n    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        // Now let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n        try borrower.close(requestId) {\n            revert(\'Cannot close PCL when principal != 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert(\'Total collateral tokens should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 10: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_exchangeRateChanges();\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 10.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_exchangeRateChanges();\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_exchangeRateChanges();\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_exchangeRateChanges();\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);\n    }\n    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero\n    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertEq(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero\n    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert(\'Borrowable amount should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly\n    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n    // Test 14: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert(\'Cannot liquidate an Active PCL with principal == 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Cannot withdraw liquidation from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawLiquidity(requestId) {\n            revert(\'Cannot withdraw liquidity from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    // Test 17: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n    // Test 17.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 18: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        vm.warp(block.timestamp + 1000);\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));\n        lender0.withdrawInterest(requestId);\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n        helper_exchangeRateChanges();\n        lender1.withdrawInterest(requestId);\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        vm.warp(block.timestamp + 1000);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n    uint256 collateralToDeposit;\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        helper_exchangeRateChanges();\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        helper_exchangeRateChanges();\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        helper_exchangeRateChanges();\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Since nothing was borrowed\n        helper_exchangeRateChanges();\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since collateral was not deposited\n        helper_exchangeRateChanges();\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        helper_exchangeRateChanges();\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n        helper_exchangeRateChanges();\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        // 1. calculateCurrentCollateralRatio\n        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        assertGt(_currentCR2, request.collateralRatio);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertGt(_currentCR3, _currentCR2);\n        helper_exchangeRateChanges();\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        helper_exchangeRateChanges();\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        helper_exchangeRateChanges();\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n        helper_exchangeRateChanges();\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertGe(_borrowable, 0);\n        helper_exchangeRateChanges();\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n        helper_exchangeRateChanges();\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Since borrower did borrow\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function test_helperFunctionsInActiveState() public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);\n    }\n    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n    function setUp() public override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n    }\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n        // Checking out what are the exchange rates\n        log_named_int(\'Borrow CToken Exchange Rate\', int256(_borrowCTokenExchangeRate));\n        log_named_int(\'Collateral CToken Exchange Rate\', int256(_collateralCTokenExchangeRate));\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n    // Test 1: An active PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n        try borrower.start(requestId) {\n            revert(\'Cannot start an Active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply\n    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly\n    // increase slowly wrt to interest rate of the pcl\n    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10_decimals).div(1e18);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);\n    }\n    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert(\'Withdrawable collateral should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        helper_exchangeRateChanges();\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n    }\n    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        // Now let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n        try borrower.close(requestId) {\n            revert(\'Cannot close PCL when principal != 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert(\'Total collateral tokens should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 10: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_exchangeRateChanges();\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 10.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_exchangeRateChanges();\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        helper_exchangeRateChanges();\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_exchangeRateChanges();\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);\n    }\n    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero\n    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertEq(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero\n    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert(\'Borrowable amount should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly\n    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n    // Test 14: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert(\'Cannot liquidate an Active PCL with principal == 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an Active PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Cannot withdraw liquidation from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawLiquidity(requestId) {\n            revert(\'Cannot withdraw liquidity from an active PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    // Test 17: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n    // Test 17.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 18: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        vm.warp(block.timestamp + 1000);\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));\n        lender0.withdrawInterest(requestId);\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n        helper_exchangeRateChanges();\n        lender1.withdrawInterest(requestId);\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        vm.warp(block.timestamp + 1000);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n    uint256 collateralToDeposit;\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n        helper_exchangeRateChanges();\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n        helper_exchangeRateChanges();\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n        helper_exchangeRateChanges();\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Since nothing was borrowed\n        helper_exchangeRateChanges();\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since collateral was not deposited\n        helper_exchangeRateChanges();\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0); // Since no collateral was deposited\n        helper_exchangeRateChanges();\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n        helper_exchangeRateChanges();\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n        // Let\'s make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n            // Transferring collateral tokens to the borrower\n            collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        // 1. calculateCurrentCollateralRatio\n        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        assertGt(_currentCR2, request.collateralRatio);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertGt(_currentCR3, _currentCR2);\n        helper_exchangeRateChanges();\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n        helper_exchangeRateChanges();\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n        helper_exchangeRateChanges();\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n        helper_exchangeRateChanges();\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertGe(_borrowable, 0);\n        helper_exchangeRateChanges();\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n        helper_exchangeRateChanges();\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Since borrower did borrow\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n    function test_helperFunctionsInActiveState() public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);\n    }\n    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:18:37 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:37 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    function setUp() public override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));
        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }
    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();
        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));
        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }
    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();
        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }
    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }
    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }
    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }
    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }
    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();
        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);
        assertLt(_collateralTokens, _collateralTokensNew);
    }
    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }
    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertEq(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_exchangeRateChanges();
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_exchangeRateChanges();
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_exchangeRateChanges();
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }
    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_exchangeRateChanges();
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }
    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }
    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertGt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }
    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);
        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }
    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));
        lender0.withdrawInterest(requestId);
        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);
        helper_exchangeRateChanges();
        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }
    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }
    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;
    uint256 collateralToDeposit;
    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        helper_exchangeRateChanges();
        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        helper_exchangeRateChanges();
        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        helper_exchangeRateChanges();
        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed
        helper_exchangeRateChanges();
        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited
        helper_exchangeRateChanges();
        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited
        helper_exchangeRateChanges();
        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);
        helper_exchangeRateChanges();
        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);
        helper_exchangeRateChanges();
        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        helper_exchangeRateChanges();
        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        helper_exchangeRateChanges();
        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);
        helper_exchangeRateChanges();
        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);
        helper_exchangeRateChanges();
        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);
        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);
        helper_exchangeRateChanges();
        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }
    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    function setUp() public override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));
        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }
    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();
        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));
        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }
    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();
        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }
    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }
    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }
    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }
    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }
    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }
    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }
    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();
        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);
        assertLt(_collateralTokens, _collateralTokensNew);
    }
    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }
    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertEq(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_exchangeRateChanges();
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_exchangeRateChanges();
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        helper_exchangeRateChanges();
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }
    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_exchangeRateChanges();
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }
    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }
    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);
        assertGt(_borrowableAmount, _borrowableAmountNew);
    }
    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }
    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);
        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }
    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));
        lender0.withdrawInterest(requestId);
        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);
        helper_exchangeRateChanges();
        lender1.withdrawInterest(requestId);
        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }
    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }
    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;
    uint256 collateralToDeposit;
    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything
        helper_exchangeRateChanges();
        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL
        helper_exchangeRateChanges();
        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place
        helper_exchangeRateChanges();
        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed
        helper_exchangeRateChanges();
        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited
        helper_exchangeRateChanges();
        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited
        helper_exchangeRateChanges();
        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);
        helper_exchangeRateChanges();
        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);
        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }
        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);
        helper_exchangeRateChanges();
        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL
        helper_exchangeRateChanges();
        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral
        helper_exchangeRateChanges();
        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);
        helper_exchangeRateChanges();
        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);
        helper_exchangeRateChanges();
        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);
        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);
        helper_exchangeRateChanges();
        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }
    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }
    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 09:18:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:18:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 45634
completion_tokens: 1
total_tokens: 45635
cost: $-1.000000


[2024-27-08 09:18:42 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Security

[2024-27-08 09:18:42 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 09:18:42 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 09:18:42 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:18:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply\n    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly\n    // increase slowly wrt to interest rate of the pcl\n    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);\n\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);\n    }\n\n    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_exchangeRateChanges();\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 10.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);\n    }\n\n    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero\n    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero\n    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly\n    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));\n\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        vm.warp(block.timestamp + 1000);\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + 1000);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Since nothing was borrowed\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since collateral was not deposited\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0); // Since no collateral was deposited\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        assertGt(_currentCR2, request.collateralRatio);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertGt(_currentCR3, _currentCR2);\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertGe(_borrowable, 0);\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Since borrower did borrow\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState() public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:18:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:42 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:18:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:18:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30377
completion_tokens: 1
total_tokens: 30378
cost: $-1.000000


[2024-27-08 09:18:49 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

###

[2024-27-08 09:18:49 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:18:49 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:18:49 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:18:49 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:49 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:19:05 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:19:05 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15248
completion_tokens: 776
total_tokens: 16024
cost: $-1.000000


[2024-27-08 09:19:05 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Based on the provided smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - The contract does not implement checks to prevent reentrancy attacks, especially in functions that involve transferring tokens or changing state variables after external calls.

2. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially when interacting with external contracts.

3. **Access Control Issues**:
   - Certain functions may lack proper access control, allowing unauthorized users to execute sensitive operations. For example, functions that modify the state of the pooled credit line should be restricted to the borrower or admin only.

4. **Gas Limit and Loops**:
   - The contract contains loops that could potentially exceed the gas limit, especially in scenarios with a large number of lenders or collateral deposits. This could lead to transaction failures.

5. **Improper Error Handling**:
   - The contract relies on revert messages that may not provide sufficient context for debugging. More descriptive error messages should be implemented to aid in identifying issues during execution.

6. **Lack of Input Validation**:
   - There are instances where user inputs are not validated, which could lead to unexpected behavior or vulnerabilities. For example, ensuring that amounts being transferred or borrowed are within acceptable limits.

7. **Token Transfer Failures**:
   - The contract does not adequately handle scenarios where token transfers fail. This could lead to inconsistencies in the state of the contract if a transfer is expected to succeed but fails.

8. **Front-Running Vulnerabilities**:
   - The contract may be susceptible to front-running attacks, where an attacker could exploit the timing of transactions to gain an advantage, especially in functions that involve price or collateral calculations.

9. **Lack of Upgradeability Considerations**:
   - The contract does not appear to have mechanisms in place for upgradeability, which could pose challenges in the future if vulnerabilities are discovered or if new features need to be added.

### Comprehensive Analysis Report

The analysis of the provided smart contract code reveals several critical security vulnerabilities that could potentially compromise the integrity and functionality of the contract. The absence of reentrancy protections, access control mechanisms, and proper error handling are particularly concerning, as they could allow unauthorized access or manipulation of the contract's state.

Moreover, the reliance on arithmetic operations without thorough validation increases the risk of integer overflow or underflow, which could lead to significant financial losses. The potential for gas limit issues due to loops further complicates the contract's reliability, especially in high-traffic scenarios.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Use the Checks-Effects-Interactions pattern and implement reentrancy guards in critical functions.
- **Enhanced Access Control**: Utilize role-based access control to restrict sensitive operations to authorized users only.
- **Input Validation**: Implement thorough checks on user inputs to ensure they are within expected ranges.
- **Error Handling Improvements**: Provide more descriptive error messages to facilitate debugging and improve user experience.
- **Gas Optimization**: Review and optimize loops to prevent exceeding gas limits, especially in functions that may process multiple entries.
- **Token Transfer Handling**: Ensure that all token transfers are checked for success and handle failures gracefully.
- **Front-Running Mitigation**: Consider implementing mechanisms to mitigate front-running risks, such as time-locks or commit-reveal schemes.
- **Upgradeability Framework**: Consider using a proxy pattern or similar approach to allow for future upgrades of the contract.

By addressing these vulnerabilities, the security and robustness of the smart contract can be significantly enhanced, ensuring a safer environment for users and their assets.

[2024-27-08 09:19:05 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - The contract does not implement checks to prevent reentrancy attacks, especially in functions that involve transferring tokens or changing state variables after external calls.

2. **Integer Overflow/Underflow**:
   - Although the contract uses SafeMath, there are still areas where arithmetic operations could lead to unexpected results if not properly handled, especially when interacting with external contracts.

3. **Access Control Issues**:
   - Certain functions may lack proper access control, allowing unauthorized users to execute sensitive operations. For example, functions that modify the state of the pooled credit line should be restricted to the borrower or admin only.

4. **Gas Limit and Loops**:
   - The contract contains loops that could potentially exceed the gas limit, especially in scenarios with a large number of lenders or collateral deposits. This could lead to transaction failures.

5. **Improper Error Handling**:
   - The contract relies on revert messages that may not provide sufficient context for debugging. More descriptive error messages should be implemented to aid in identifying issues during execution.

6. **Lack of Input Validation**:
   - There are instances where user inputs are not validated, which could lead to unexpected behavior or vulnerabilities. For example, ensuring that amounts being transferred or borrowed are within acceptable limits.

7. **Token Transfer Failures**:
   - The contract does not adequately handle scenarios where token transfers fail. This could lead to inconsistencies in the state of the contract if a transfer is expected to succeed but fails.

8. **Front-Running Vulnerabilities**:
   - The contract may be susceptible to front-running attacks, where an attacker could exploit the timing of transactions to gain an advantage, especially in functions that involve price or collateral calculations.

9. **Lack of Upgradeability Considerations**:
   - The contract does not appear to have mechanisms in place for upgradeability, which could pose challenges in the future if vulnerabilities are discovered or if new features need to be added.

### Comprehensive Analysis Report

The analysis of the provided smart contract code reveals several critical security vulnerabilities that could potentially compromise the integrity and functionality of the contract. The absence of reentrancy protections, access control mechanisms, and proper error handling are particularly concerning, as they could allow unauthorized access or manipulation of the contract's state.

Moreover, the reliance on arithmetic operations without thorough validation increases the risk of integer overflow or underflow, which could lead to significant financial losses. The potential for gas limit issues due to loops further complicates the contract's reliability, especially in high-traffic scenarios.

To mitigate these vulnerabilities, it is recommended to implement the following measures:

- **Reentrancy Guards**: Use the Checks-Effects-Interactions pattern and implement reentrancy guards in critical functions.
- **Enhanced Access Control**: Utilize role-based access control to restrict sensitive operations to authorized users only.
- **Input Validation**: Implement thorough checks on user inputs to ensure they are within expected ranges.
- **Error Handling Improvements**: Provide more descriptive error messages to facilitate debugging and improve user experience.
- **Gas Optimization**: Review and optimize loops to prevent exceeding gas limits, especially in functions that may process multiple entries.
- **Token Transfer Handling**: Ensure that all token transfers are checked for success and handle failures gracefully.
- **Front-Running Mitigation**: Consider implementing mechanisms to mitigate front-running risks, such as time-locks or commit-reveal schemes.
- **Upgradeability Framework**: Consider using a proxy pattern or similar approach to allow for future upgrades of the contract.

By addressing these vulnerabilities, the security and robustness of the smart contract can be significantly enhanced, ensuring a safer environment for users and their assets.

[2024-27-08 09:19:05 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:19:05 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply\n    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly\n    // increase slowly wrt to interest rate of the pcl\n    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);\n\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);\n    }\n\n    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_exchangeRateChanges();\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 10.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);\n    }\n\n    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero\n    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero\n    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly\n    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));\n\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        vm.warp(block.timestamp + 1000);\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + 1000);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Since nothing was borrowed\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since collateral was not deposited\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0); // Since no collateral was deposited\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        assertGt(_currentCR2, request.collateralRatio);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertGt(_currentCR3, _currentCR2);\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertGe(_borrowable, 0);\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Since borrower did borrow\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState() public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:19:05 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:19:05 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:19:09 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:19:09 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30377
completion_tokens: 1
total_tokens: 30378
cost: $-1.000000


[2024-27-08 09:19:09 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

###

[2024-27-08 09:19:09 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:19:09 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:19:09 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:19:09 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:19:09 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:19:21 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:19:21 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15248
completion_tokens: 664
total_tokens: 15912
cost: $-1.000000


[2024-27-08 09:19:21 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Based on the provided Solidity smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not implement checks to prevent reentrancy attacks, especially in functions that involve transferring tokens or interacting with external contracts. This could allow malicious actors to exploit the contract by recursively calling functions before the previous execution is completed.

2. **Arithmetic Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where arithmetic operations could still lead to overflow or underflow if not properly handled. It is crucial to ensure that all arithmetic operations are safeguarded.

3. **Access Control Issues**:
   - Certain functions may lack proper access control mechanisms, allowing unauthorized users to execute sensitive operations. This could lead to unauthorized fund withdrawals or contract state changes.

4. **Gas Limit and Loops**:
   - The contract contains loops that could potentially exceed the gas limit, especially when dealing with large arrays or mappings. This could lead to failed transactions and denial of service.

5. **Unvalidated External Calls**:
   - The contract makes external calls to other contracts without validating their responses. This could lead to unexpected behavior if the external contract is compromised or behaves maliciously.

6. **Lack of Event Logging**:
   - Important state changes and actions are not logged with events, making it difficult to track contract activity and debug issues. Proper event logging is essential for transparency and auditing.

7. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. This could lead to inconsistencies in the contract state and unexpected behavior.

8. **Potential for Front-Running**:
   - The contract may be susceptible to front-running attacks, where an attacker can observe pending transactions and execute their own transactions to gain an advantage.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could potentially compromise the integrity and functionality of the contract. The most critical issues include the risk of reentrancy attacks, which could allow malicious actors to exploit the contract's functions, especially those involving token transfers. 

Additionally, while the use of `SafeMath` mitigates some risks associated with arithmetic operations, it is essential to ensure that all operations are carefully managed to prevent overflow and underflow scenarios. Access control mechanisms must be rigorously enforced to prevent unauthorized access to sensitive functions.

The contract's reliance on external calls without validation poses a significant risk, as it could lead to unexpected behaviors if the external contracts are compromised. Furthermore, the absence of event logging for important actions hampers the ability to audit and track contract activity effectively.

To enhance the security posture of the contract, it is recommended to implement the following measures:
- Introduce reentrancy guards in critical functions.
- Ensure all arithmetic operations are validated and handled appropriately.
- Implement robust access control mechanisms.
- Avoid loops that could exceed gas limits or introduce complexity.
- Validate responses from external calls and handle failures gracefully.
- Incorporate event logging for all significant state changes.
- Consider mechanisms to mitigate front-running risks.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting user funds and maintaining trust in the system.

[2024-27-08 09:19:21 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities:

1. **Reentrancy Attacks**:
   - The contract does not implement checks to prevent reentrancy attacks, especially in functions that involve transferring tokens or interacting with external contracts. This could allow malicious actors to exploit the contract by recursively calling functions before the previous execution is completed.

2. **Arithmetic Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there are instances where arithmetic operations could still lead to overflow or underflow if not properly handled. It is crucial to ensure that all arithmetic operations are safeguarded.

3. **Access Control Issues**:
   - Certain functions may lack proper access control mechanisms, allowing unauthorized users to execute sensitive operations. This could lead to unauthorized fund withdrawals or contract state changes.

4. **Gas Limit and Loops**:
   - The contract contains loops that could potentially exceed the gas limit, especially when dealing with large arrays or mappings. This could lead to failed transactions and denial of service.

5. **Unvalidated External Calls**:
   - The contract makes external calls to other contracts without validating their responses. This could lead to unexpected behavior if the external contract is compromised or behaves maliciously.

6. **Lack of Event Logging**:
   - Important state changes and actions are not logged with events, making it difficult to track contract activity and debug issues. Proper event logging is essential for transparency and auditing.

7. **Token Transfer Failures**:
   - The contract does not handle scenarios where token transfers fail. This could lead to inconsistencies in the contract state and unexpected behavior.

8. **Potential for Front-Running**:
   - The contract may be susceptible to front-running attacks, where an attacker can observe pending transactions and execute their own transactions to gain an advantage.

### Comprehensive Analysis Report:

The provided smart contract code exhibits several security vulnerabilities that could potentially compromise the integrity and functionality of the contract. The most critical issues include the risk of reentrancy attacks, which could allow malicious actors to exploit the contract's functions, especially those involving token transfers. 

Additionally, while the use of `SafeMath` mitigates some risks associated with arithmetic operations, it is essential to ensure that all operations are carefully managed to prevent overflow and underflow scenarios. Access control mechanisms must be rigorously enforced to prevent unauthorized access to sensitive functions.

The contract's reliance on external calls without validation poses a significant risk, as it could lead to unexpected behaviors if the external contracts are compromised. Furthermore, the absence of event logging for important actions hampers the ability to audit and track contract activity effectively.

To enhance the security posture of the contract, it is recommended to implement the following measures:
- Introduce reentrancy guards in critical functions.
- Ensure all arithmetic operations are validated and handled appropriately.
- Implement robust access control mechanisms.
- Avoid loops that could exceed gas limits or introduce complexity.
- Validate responses from external calls and handle failures gracefully.
- Incorporate event logging for all significant state changes.
- Consider mechanisms to mitigate front-running risks.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting user funds and maintaining trust in the system.

[2024-27-08 09:19:21 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:19:21 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply\n    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly\n    // increase slowly wrt to interest rate of the pcl\n    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);\n\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);\n    }\n\n    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_exchangeRateChanges();\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 10.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);\n    }\n\n    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero\n    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero\n    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly\n    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));\n\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        vm.warp(block.timestamp + 1000);\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + 1000);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Since nothing was borrowed\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since collateral was not deposited\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0); // Since no collateral was deposited\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        assertGt(_currentCR2, request.collateralRatio);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertGt(_currentCR3, _currentCR2);\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertGe(_borrowable, 0);\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Since borrower did borrow\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState() public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:19:21 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:19:21 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:19:25 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:19:25 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 30377
completion_tokens: 1
total_tokens: 30378
cost: $-1.000000


[2024-27-08 09:19:25 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

###

[2024-27-08 09:19:25 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:19:25 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:19:25 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:19:25 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:19:25 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:19:36 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:19:36 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 15248
completion_tokens: 732
total_tokens: 15980
cost: $-1.000000


[2024-27-08 09:19:36 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Based on the provided smart contract code for the `PCLActiveStateCToken` and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are properly guarded against overflow and underflow, especially in critical calculations involving collateral and debt.

3. **Access Control Issues**:
   - There may be insufficient access control on certain functions, allowing unauthorized users to execute sensitive operations, such as terminating the PCL or withdrawing funds.

4. **Improper Handling of External Calls**:
   - The contract makes external calls to other contracts (e.g., transferring tokens). If these external contracts are malicious or fail, it could lead to unexpected behavior or loss of funds.

5. **Lack of Input Validation**:
   - There is a lack of thorough input validation in functions that accept user inputs, which could lead to unexpected states or vulnerabilities if invalid data is processed.

6. **Gas Limit and Loops**:
   - Some functions may involve loops that could exceed the gas limit, especially if the number of iterations is dependent on user input or external state. This could lead to denial of service.

7. **Price Manipulation Risks**:
   - The contract relies on external price feeds (e.g., from a price oracle). If these feeds are manipulated, it could lead to incorrect collateralization ratios and allow for exploitation.

8. **Lack of Event Emissions**:
   - Certain state-changing operations do not emit events, which can hinder tracking and auditing of contract activity. This is crucial for transparency and debugging.

9. **Potential for Front-Running**:
   - The contract may be susceptible to front-running attacks, where an attacker can observe pending transactions and execute their own transactions first to gain an advantage.

### Comprehensive Analysis Report

The `PCLActiveStateCToken` contract exhibits several security vulnerabilities that could be exploited by malicious actors, potentially leading to significant financial losses and operational failures. Key areas of concern include the absence of reentrancy guards, which could allow for reentrancy attacks during token transfers or state changes. While the use of `SafeMath` mitigates overflow and underflow risks, it is critical to ensure that all arithmetic operations are adequately safeguarded.

Access control mechanisms must be rigorously implemented to prevent unauthorized access to sensitive functions. Additionally, the contract's reliance on external calls and price feeds introduces risks that must be managed through careful validation and monitoring.

Input validation is another critical area that requires attention, as improper handling of user inputs could lead to unexpected states. The potential for gas limit issues in looping structures must also be addressed to prevent denial of service attacks.

The lack of event emissions for certain operations can hinder transparency and make it difficult to trace contract activity, which is essential for auditing purposes. Furthermore, the contract's design may expose it to front-running risks, necessitating the implementation of measures to mitigate such vulnerabilities.

In conclusion, a thorough security audit and the implementation of best practices in smart contract development are essential to address these vulnerabilities. This includes employing reentrancy guards, enhancing access control, validating inputs, and ensuring proper event logging. Continuous monitoring and updates to the contract will also be necessary to adapt to evolving security threats in the blockchain ecosystem.

[2024-27-08 09:19:36 INFO] **[Seminar Conclusion]**:

 Based on the provided smart contract code for the `PCLActiveStateCToken` and the analysis reports, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Attacks**:
   - The contract does not implement any reentrancy guards, which could allow malicious actors to exploit functions that transfer tokens or modify state variables, potentially leading to unexpected behavior or loss of funds.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, it is essential to ensure that all arithmetic operations are properly guarded against overflow and underflow, especially in critical calculations involving collateral and debt.

3. **Access Control Issues**:
   - There may be insufficient access control on certain functions, allowing unauthorized users to execute sensitive operations, such as terminating the PCL or withdrawing funds.

4. **Improper Handling of External Calls**:
   - The contract makes external calls to other contracts (e.g., transferring tokens). If these external contracts are malicious or fail, it could lead to unexpected behavior or loss of funds.

5. **Lack of Input Validation**:
   - There is a lack of thorough input validation in functions that accept user inputs, which could lead to unexpected states or vulnerabilities if invalid data is processed.

6. **Gas Limit and Loops**:
   - Some functions may involve loops that could exceed the gas limit, especially if the number of iterations is dependent on user input or external state. This could lead to denial of service.

7. **Price Manipulation Risks**:
   - The contract relies on external price feeds (e.g., from a price oracle). If these feeds are manipulated, it could lead to incorrect collateralization ratios and allow for exploitation.

8. **Lack of Event Emissions**:
   - Certain state-changing operations do not emit events, which can hinder tracking and auditing of contract activity. This is crucial for transparency and debugging.

9. **Potential for Front-Running**:
   - The contract may be susceptible to front-running attacks, where an attacker can observe pending transactions and execute their own transactions first to gain an advantage.

### Comprehensive Analysis Report

The `PCLActiveStateCToken` contract exhibits several security vulnerabilities that could be exploited by malicious actors, potentially leading to significant financial losses and operational failures. Key areas of concern include the absence of reentrancy guards, which could allow for reentrancy attacks during token transfers or state changes. While the use of `SafeMath` mitigates overflow and underflow risks, it is critical to ensure that all arithmetic operations are adequately safeguarded.

Access control mechanisms must be rigorously implemented to prevent unauthorized access to sensitive functions. Additionally, the contract's reliance on external calls and price feeds introduces risks that must be managed through careful validation and monitoring.

Input validation is another critical area that requires attention, as improper handling of user inputs could lead to unexpected states. The potential for gas limit issues in looping structures must also be addressed to prevent denial of service attacks.

The lack of event emissions for certain operations can hinder transparency and make it difficult to trace contract activity, which is essential for auditing purposes. Furthermore, the contract's design may expose it to front-running risks, necessitating the implementation of measures to mitigate such vulnerabilities.

In conclusion, a thorough security audit and the implementation of best practices in smart contract development are essential to address these vulnerabilities. This includes employing reentrancy guards, enhancing access control, validating inputs, and ensuring proper event logging. Continuous monitoring and updates to the contract will also be necessary to adapt to evolving security threats in the blockchain ecosystem.

[2024-27-08 09:19:40 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 1 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An active PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an Active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply\n    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly\n    // increase slowly wrt to interest rate of the pcl\n    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);\n\n        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);\n    }\n\n    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.withdrawableCollateral(requestId) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);\n\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);\n    }\n\n    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);\n    }\n\n    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        borrower.withdrawAllCollateral(requestId, false);\n    }\n\n    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero\n    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Withdrawable collateral should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        helper_exchangeRateChanges();\n        borrower.close(requestId);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        // Now let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An active PCL cannot be cancelled if principal == 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 10.1: An active PCL cannot be cancelled if principal != 0\n    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0\n    function test_adminCanTerminatePCLPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0\n    function test_adminCanTerminatePCLPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted\n    }\n\n    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply\n    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(\n            address(collateralAsset),\n            address(borrowAsset)\n        );\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);\n    }\n\n    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero\n    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero\n    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateBorrowableAmount(requestId) {\n            revert('Borrowable amount should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly\n    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);\n\n        assertGt(_borrowableAmount, _borrowableAmountNew);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An active PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an Active PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, request.borrowLimit / 2);\n\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an Active PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral and borrow now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));\n\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an active PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an Active PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0\n    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst price fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        vm.warp(block.timestamp + 1000);\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));\n\n        lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, _collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        vm.warp(block.timestamp + 1000);\n        // Borrower makes their first repayment (Entire pending interest + part of principal)\n        {\n            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));\n            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);\n            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);\n            borrower.repay(requestId, interestAccrued + 10);\n        }\n\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertEq(_currentDebt, 0); // Since nothing was borrowed\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since collateral was not deposited\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertEq(_totalCollateral, 0); // Since no collateral was deposited\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal == 0, 'Principal != 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);\n\n        // Let's make the principal non-zero\n        // Borrower deposits collateral into the PCL\n        {\n            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio\n            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n            // Transferring collateral tokens to the borrower\n            collateralToDeposit = minimumCollateralRequired.mul(2);\n            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);\n            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n            // We want to deposit collateral now\n            borrower.depositCollateral(requestId, collateralToDeposit, false);\n        }\n\n        // Borrower borrows from the PCL\n        uint256 borrowableAmount;\n        {\n            borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n            borrower.borrow(requestId, borrowableAmount / 2);\n            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);\n            assertGt(currentCollateralRatio, request.collateralRatio);\n        }\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        assertGt(_currentCR2, request.collateralRatio);\n\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertGt(_currentCR3, _currentCR2);\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertGe(_borrowable, 0);\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0); // Since borrower did borrow\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);\n    }\n\n    function test_helperFunctionsInActiveState() public {\n        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);\n    }\n\n    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {\n        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 09:19:40 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 1 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An active PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an Active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertLt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly // increase slowly wrt to interest rate of the pcl function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertGt(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);      assertEq(_withdrawableCollateral, _withdrawableCollateralNew); }  // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.withdrawableCollateral(requestId) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);      borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false); }  // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawCollateral(requestId, _withdrawableCollateral, false); }  // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     borrower.withdrawAllCollateral(requestId, false); }  // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try borrower.withdrawAllCollateral(requestId, false) {         revert('Withdrawable collateral should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     helper_exchangeRateChanges();     borrower.close(requestId);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');      // Now let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An active PCL cannot be cancelled if principal == 0 function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 10.1: An active PCL cannot be cancelled if principal != 0 function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0 function test_adminCanTerminatePCLPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0 function test_adminCanTerminatePCLPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted }  // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew); }  // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(         address(collateralAsset),         address(borrowAsset)     );     uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued); }  // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, _borrowableAmountNew); }  // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateBorrowableAmount(requestId) {         revert('Borrowable amount should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);      assertGt(_borrowableAmount, _borrowableAmountNew); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An active PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an Active PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_increaseExchangeRateSteeply(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(borrowCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, request.borrowLimit / 2);      helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an Active PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral and borrow now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));      helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(requestId, false);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an active PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an Active PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0 function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst price fluctuations function test_lendersCanWithdrawInterest() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      // Borrower makes their first repayment (Entire pending interest + part of principal)     vm.warp(block.timestamp + 1000);     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));      lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, _collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      vm.warp(block.timestamp + 1000);     // Borrower makes their first repayment (Entire pending interest + part of principal)     {         borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));         uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);         admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);         borrower.repay(requestId, interestAccrued + 10);     }      PCLUser lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertEq(_currentDebt, 0); // Since nothing was borrowed      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since collateral was not deposited      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertEq(_totalCollateral, 0); // Since no collateral was deposited      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertEq(_interestAccrued, 0); // Since borrower did not borrow anything      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {     PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal == 0, 'Principal != 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);      // Let's make the principal non-zero     // Borrower deposits collateral into the PCL     {         // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio         uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);          // Transferring collateral tokens to the borrower         collateralToDeposit = minimumCollateralRequired.mul(2);         admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);         borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);          // We want to deposit collateral now         borrower.depositCollateral(requestId, collateralToDeposit, false);     }      // Borrower borrows from the PCL     uint256 borrowableAmount;     {         borrowableAmount = borrower.calculateBorrowableAmount(requestId);         borrower.borrow(requestId, borrowableAmount / 2);         uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);         assertGt(currentCollateralRatio, request.collateralRatio);     }      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);      // 1. calculateCurrentCollateralRatio     _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));     assertGt(_currentCR2, request.collateralRatio);      helper_increaseExchangeRateSteeply(collateralCTokenAddress);      _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);     assertGt(_currentCR3, _currentCR2);      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertGe(_borrowable, 0);      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0); // Since borrower did borrow      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE); }  function test_helperFunctionsInActiveState() public {     assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId); }  function test_helperFunctionsInActiveStateNonZeroPrincipal() public {     assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:19:40 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLActiveStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 1 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An active PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an Active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral increases if collateral CToken exchange rate increases steeply
    function test_withdrawableCollateralIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertLt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.1: Withdrawable collateral decreases if collateral CToken exchange rate increases very slowly
    // increase slowly wrt to interest rate of the pcl
    function test_withdrawableCollateralDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertGt(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.2: Withdrawable collateral remains unchanged if borrow CToken exchange rate decreases to zero
    function test_withdrawableCollateralRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _withdrawableCollateralNew = pcl.withdrawableCollateral(requestId);

        assertEq(_withdrawableCollateral, _withdrawableCollateralNew);
    }

    // Test 3.3: Withdrawable collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawableCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.withdrawableCollateral(requestId) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 4: Withdraw collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.1: Withdraw collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _additionalDebtCollateral = _interestAccrued.mul(request.collateralRatio).div(_ratioOfPrices).mul(10**_decimals).div(1e18);

        borrower.withdrawCollateral(requestId, _withdrawableCollateral - _additionalDebtCollateral, false);
    }

    // Test 4.2: Withdraw collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawCollateral(requestId, _withdrawableCollateral, false);
    }

    // Test 4.3: Withdraw collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawCollateral(requestId, _withdrawableCollateral, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 5: Withdraw all collateral works if collateral CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.1: Withdraw all collateral works if borrow CToken exchange rate increases steeply
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.2: Withdraw all collateral works if borrow CToken exchange rate decreases to zero
    function test_withdrawAllCollateralWorksIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        borrower.withdrawAllCollateral(requestId, false);
    }

    // Test 5.3: Withdraw all collateral reverts if collateral CToken exchange rate decreases to zero
    function test_withdrawAllCollateralRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Withdrawable collateral should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 6: An active PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        borrower.close(requestId);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An active PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');

        // Now let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An active PCL cannot be cancelled if principal == 0
    function test_borrowerCannotCancelActivePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 10.1: An active PCL cannot be cancelled if principal != 0
    function test_borrowerCannotCancelActivePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an ACTIVE PCL with principal == 0
    function test_adminCanTerminatePCLPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertTrue((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate) == 0); // Since no collateral was ever deposited
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 11.1: Admin should be able to terminate an ACTIVE PCL with principal != 0
    function test_adminCanTerminatePCLPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0); // Since collateral was also extracted
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); // Since the lent amount (which was still in the PCL/LP contracts) were extracted
    }

    // Test 12: Borrowable amount increases if collateral CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.1: Borrowable amount increases if borrow CToken exchange rate increases steeply
    function test_borrowableAmountIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        (uint256 _ratioOfPrices, uint256 _decimals) = IPriceOracle(priceOracleAddress).getLatestPrice(
            address(collateralAsset),
            address(borrowAsset)
        );
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertLt(_borrowableAmount, _borrowableAmountNew + _interestAccrued);
    }

    // Test 12.2: Borrowable amount remains same if borrow CToken exchange rate decreases to zero
    function test_borrowableAmountRemainsSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 12.3: Borrowable amount reverts if collateral CToken exchange rate decreases to zero
    function test_borrowableAmountRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateBorrowableAmount(requestId) {
            revert('Borrowable amount should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 12.4: Borrowable amount decreases if collateral CToken exchange rate increases very slowly
    function test_borrowableAmountDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _borrowableAmountNew = pcl.calculateBorrowableAmount(requestId);

        assertGt(_borrowableAmount, _borrowableAmountNew);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An active PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an Active PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An active PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An active PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An active PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An active PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, request.borrowLimit / 2);

        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an Active PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An active PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral and borrow now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        borrower.borrow(requestId, pcl.calculateBorrowableAmount(requestId));

        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(requestId, false);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an ACTIVE pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an active PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an Active PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 17.2: Pool token transfers should be possible in an Active PCL and principal != 0
    function test_poolTokenTransfersShouldBePossiblePartialBalancePrincipalIsNonZero() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst price fluctuations
    function test_lendersCanWithdrawInterest() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        // Borrower makes their first repayment (Entire pending interest + part of principal)
        vm.warp(block.timestamp + 1000);
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender1));

        lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            uint256 _collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), _collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, _collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        vm.warp(block.timestamp + 1000);
        // Borrower makes their first repayment (Entire pending interest + part of principal)
        {
            borrower.setAllowance(address(pcl), address(borrowAsset), uint256(-1));
            uint256 interestAccrued = borrower.calculateInterestAccrued(requestId);
            admin.transferToken(address(borrowAsset), address(borrower), interestAccrued * 10);
            borrower.repay(requestId, interestAccrued + 10);
        }

        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInActiveStateZeroPrincipal(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertEq(_currentCR1, uint256(-1)); // Since borrower has not yet borrowed anything

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral was deposited in the first place

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertEq(_currentDebt, 0); // Since nothing was borrowed

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since collateral was not deposited

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertEq(_totalCollateral, 0); // Since no collateral was deposited

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertEq(_interestAccrued, 0); // Since borrower did not borrow anything

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(uint256 _id) public {
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal == 0, 'Principal != 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE);

        // Let's make the principal non-zero
        // Borrower deposits collateral into the PCL
        {
            // Calculating the number of collateral tokens required to match and go above the ideal collateral ratio
            uint256 minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

            // Transferring collateral tokens to the borrower
            collateralToDeposit = minimumCollateralRequired.mul(2);
            admin.transferToken(address(collateralAsset), address(borrower), collateralToDeposit);
            borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

            // We want to deposit collateral now
            borrower.depositCollateral(requestId, collateralToDeposit, false);
        }

        // Borrower borrows from the PCL
        uint256 borrowableAmount;
        {
            borrowableAmount = borrower.calculateBorrowableAmount(requestId);
            borrower.borrow(requestId, borrowableAmount / 2);
            uint256 currentCollateralRatio = borrower.calculateCurrentCollateralRatio(requestId);
            assertGt(currentCollateralRatio, request.collateralRatio);
        }

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);

        // 1. calculateCurrentCollateralRatio
        _currentCR2 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        assertGt(_currentCR2, request.collateralRatio);

        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        _currentCR3 = _borrower.calculateCurrentCollateralRatio(_id);
        assertGt(_currentCR3, _currentCR2);

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _borrower.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since lenders cannot withdraw funds from an active PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertGe(_withdrawableCollateral, 0); // Since we had deposited twice the reqired collateral

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertGe(_borrowable, 0);

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0); // Since borrower did borrow

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.ACTIVE);
    }

    function test_helperFunctionsInActiveState() public {
        assert_helperFunctionalitiesInActiveStateZeroPrincipal(requestId);
    }

    function test_helperFunctionsInActiveStateNonZeroPrincipal() public {
        assertHelperFunctionalitiesInActiveStateNonZeroPrincipal(requestId);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

