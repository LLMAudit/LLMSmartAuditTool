[2024-27-08 09:17:39 INFO] **[Preprocessing]**

**ChatDev Starts** (20240827091739)

**Timestamp**: 20240827091739

**config_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/ChatChainConfig.json

**config_phase_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/PhaseConfig.json

**config_role_path**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/CompanyConfig/SmartContractBA/RoleConfig.json

**task_prompt**: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}


**project_name**: RealWorld_BA_101_PCLExpiredState.t

**Log File**: /Users/weizhiyuan/Documents/code/SC_LLM_ChatDev/WareHouse/RealWorld_BA_101_PCLExpiredState.t_RealWord_20240827091739.log

**ChatDevConfig**:
ChatEnvConfig.with_memory: False
ChatEnvConfig.clear_structure: True
ChatEnvConfig.git_management: False
ChatEnvConfig.gui_design: True
ChatEnvConfig.incremental_develop: False
ChatEnvConfig.background_prompt: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.


**ChatGPTConfig**:
ChatGPTConfig(temperature=0.2, top_p=1.0, n=1, stream=False, stop=None, max_tokens=None, presence_penalty=0.0, frequency_penalty=0.0, logit_bias={}, user='')



[2024-27-08 09:17:39 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | True |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **phase_prompt** | We excel in generating innovative approaches and enhancements for Solidity smart contract code. Here's a Solidity contract provided by the user: "{task}". As the {assistant_role}, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user. Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions". |
| **phase_name** | ContractAnalysis |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 50 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral remains zero\n    function test_withdrawableCollateralIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, 0);\n    }\n\n    // Test 4: Withdraw collateral should revert\n    function test_withdrawCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawCollateral(requestId, 1, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral should revert\n    function test_withdrawAllCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An expired PCL cannot be cancelled\n    function test_borrowerCannotCancel() public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an expired PCL\n    function test_adminCanTerminatePCL() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 12: Borrowable amount remains zero\n    function test_borrowableAmountIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, 0);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An expired PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an expired PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt - 10000);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(_requestId, _requiredCollateral, false);\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 2);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(_requestId, currentDebt / 100);\n\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an expired pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an expired pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));\n\n        _lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        _lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since the state is expired\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0);\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_helperFunctionalitiesInExpiredState() public {\n        assert_helperFunctionalitiesInExpiredState(requestId);\n    }\n}\n"} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:17:39 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Chief Executive Officer |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:17:39 INFO] Chief Executive Officer: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

We excel in generating innovative approaches and enhancements for Solidity smart contract code.

Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
".

As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.

Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

[2024-27-08 09:17:42 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:17:42 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17016
completion_tokens: 1
total_tokens: 17017
cost: $-1.000000


[2024-27-08 09:17:42 INFO] Security Analyst: **Security Analyst<->Chief Executive Officer on : ContractAnalysis, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Let's

[2024-27-08 09:17:42 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **phase_prompt** | Here is a conversation between two roles: {conversations} {question} |
| **phase_name** | Reflection |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **placeholders** | {'conversations': 'Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.\nYou are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.\nYou can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites\nHere is a new customer\'s task: // SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n    function setUp() public override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 50 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n        // Borrower decides to repay everything at mid-duration\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(requestId, currentDebt / 2);\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n    }\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n        // Checking out what are the exchange rates\n        log_named_int(\'Borrow CToken Exchange Rate\', int256(_borrowCTokenExchangeRate));\n        log_named_int(\'Collateral CToken Exchange Rate\', int256(_collateralCTokenExchangeRate));\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n        try borrower.start(requestId) {\n            revert(\'Cannot start an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n    // Test 3: Withdrawable collateral remains zero\n    function test_withdrawableCollateralIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, 0);\n    }\n    // Test 4: Withdraw collateral should revert\n    function test_withdrawCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        try borrower.withdrawCollateral(requestId, 1, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    // Test 5: Withdraw all collateral should revert\n    function test_withdrawAllCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WAC1\');\n        }\n    }\n    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n    }\n    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n        try borrower.close(requestId) {\n            revert(\'Cannot close PCL when principal != 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert(\'Total collateral tokens should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 10: An expired PCL cannot be cancelled\n    function test_borrowerCannotCancel() public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_exchangeRateChanges();\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 11: Admin should be able to terminate an expired PCL\n    function test_adminCanTerminatePCL() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);\n        helper_exchangeRateChanges();\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n    // Test 12: Borrowable amount remains zero\n    function test_borrowableAmountIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        assertEq(_borrowableAmount, 0);\n    }\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n    // Test 14: An expired PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert(\'Cannot liquidate an expired PCL with principal == 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt - 10000);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n        vm.warp(block.timestamp + request.duration / 2);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(_requestId, currentDebt / 100);\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 15: Lenders cannot withdraw liquidation from an expired pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Cannot withdraw liquidation from an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    // Test 16: Lenders cannot withdraw liquidity from an expired pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawLiquidity(requestId) {\n            revert(\'Cannot withdraw liquidity from an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    // Test 17: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n    // Test 17.1: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));\n        _lender0.withdrawInterest(requestId);\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n        helper_exchangeRateChanges();\n        _lender1.withdrawInterest(requestId);\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n    uint256 collateralToDeposit;\n    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        helper_exchangeRateChanges();\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL\n        helper_exchangeRateChanges();\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state\n        helper_exchangeRateChanges();\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n        helper_exchangeRateChanges();\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since the state is expired\n        helper_exchangeRateChanges();\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n        helper_exchangeRateChanges();\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n        helper_exchangeRateChanges();\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0);\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function test_helperFunctionalitiesInExpiredState() public {\n        assert_helperFunctionalitiesInExpiredState(requestId);\n    }\n}\n.\n\nChief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.\nHere\'s a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\nimport \'@openzeppelin/contracts/token/ERC20/SafeERC20.sol\';\nimport \'@openzeppelin/contracts/math/SafeMath.sol\';\nimport \'@openzeppelin/contracts/token/ERC20/IERC20.sol\';\nimport \'../../../SublimeProxy.sol\';\nimport \'../../../PooledCreditLine/PooledCreditLine.sol\';\nimport \'../../../PooledCreditLine/LenderPool.sol\';\nimport \'../../../PriceOracle.sol\';\nimport \'../../../SavingsAccount/SavingsAccount.sol\';\nimport \'../../../yield/StrategyRegistry.sol\';\nimport \'../../../yield/NoYield.sol\';\nimport \'../../../yield/CompoundYield.sol\';\nimport \'../../../mocks/MockWETH.sol\';\nimport \'../../../mocks/MockCToken.sol\';\nimport \'../../../mocks/MockVerification2.sol\';\nimport \'../../../mocks/MockV3Aggregator.sol\';\nimport \'../../../mocks/MockToken.sol\';\nimport \'../../../interfaces/IPooledCreditLineDeclarations.sol\';\nimport \'../../../interfaces/ISavingsAccount.sol\';\nimport \'../Helpers/PCLParent.t.sol\';\ncontract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n    function setUp() public override {\n        super.setUp();\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 50 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, \'!Active\');\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n        // Borrower decides to repay everything at mid-duration\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(requestId, currentDebt / 2);\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n    }\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n        // Checking out what are the exchange rates\n        log_named_int(\'Borrow CToken Exchange Rate\', int256(_borrowCTokenExchangeRate));\n        log_named_int(\'Collateral CToken Exchange Rate\', int256(_collateralCTokenExchangeRate));\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n        try borrower.start(requestId) {\n            revert(\'Cannot start an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:S1\');\n        }\n    }\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n    // Test 3: Withdrawable collateral remains zero\n    function test_withdrawableCollateralIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, 0);\n    }\n    // Test 4: Withdraw collateral should revert\n    function test_withdrawCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        try borrower.withdrawCollateral(requestId, 1, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WC1\');\n        }\n    }\n    // Test 5: Withdraw all collateral should revert\n    function test_withdrawAllCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert(\'Should not be able to withdraw\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:WAC1\');\n        }\n    }\n    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, \'!Closed\');\n    }\n    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n        try borrower.close(requestId) {\n            revert(\'Cannot close PCL when principal != 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:C2\');\n        }\n    }\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert(\'Total collateral tokens should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert(\'Collateral ratio should revert\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n    // Test 10: An expired PCL cannot be cancelled\n    function test_borrowerCannotCancel() public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        helper_exchangeRateChanges();\n        try borrower.cancelRequest(requestId) {\n            revert(\'Cannot cancel an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:CR1\');\n        }\n    }\n    // Test 11: Admin should be able to terminate an expired PCL\n    function test_adminCanTerminatePCL() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);\n        helper_exchangeRateChanges();\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n    // Test 12: Borrowable amount remains zero\n    function test_borrowableAmountIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n        assertEq(_borrowableAmount, 0);\n    }\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n    // Test 14: An expired PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, \'Principal == 0\');\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, \'Principal != 0\');\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert(\'Cannot liquidate an expired PCL with principal == 0\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L1\');\n        }\n    }\n    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt - 10000);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'PCL:L3\');\n        }\n    }\n    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try _lender0.liquidate(requestId, false) {\n            revert(\'Cannot liquidate an expired PCL with CR &gt;= ICR\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'CY:GTFS1\');\n        }\n    }\n    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(_requestId, _requiredCollateral, false);\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n        vm.warp(block.timestamp + request.duration / 2);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(_requestId, currentDebt / 100);\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, \'!Expired\');\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n    // Test 15: Lenders cannot withdraw liquidation from an expired pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert(\'Cannot withdraw liquidation from an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWLC1\');\n        }\n    }\n    // Test 16: Lenders cannot withdraw liquidity from an expired pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n        try _lender0.withdrawLiquidity(requestId) {\n            revert(\'Cannot withdraw liquidity from an expired PCL\');\n        } catch Error(string memory reason) {\n            assertEq(reason, \'LP:IWL3\');\n        }\n    }\n    // Test 17: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n    // Test 17.1: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));\n        _lender0.withdrawInterest(requestId);\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n        helper_exchangeRateChanges();\n        _lender1.withdrawInterest(requestId);\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n    uint256 collateralToDeposit;\n    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n        helper_exchangeRateChanges();\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL\n        helper_exchangeRateChanges();\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state\n        helper_exchangeRateChanges();\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n        helper_exchangeRateChanges();\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since the state is expired\n        helper_exchangeRateChanges();\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n        helper_exchangeRateChanges();\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n        helper_exchangeRateChanges();\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0);\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n    function test_helperFunctionalitiesInExpiredState() public {\n        assert_helperFunctionalitiesInExpiredState(requestId);\n    }\n}\n".\nAs the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.\nNote that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we\'ve collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with , followed directly by the final idea or enhancement suggestion, e.g. " Implementing a multi-sig wallet mechanism for added security in transactions".\n\nSecurity Analyst: Let\'s', 'question': 'Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" '} |
| **need_reflect** | False |
| **memory** | No existed memory |
| **chat_turn_limit** | 1 |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:17:42 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Chief Executive Officer |
| **user_role_name** | Counselor |
| **assistant_role_prompt** | {chatdev_prompt} You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer. Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer. Your main responsibilities include asking what user and customer think and provide your valuable suggestions.  Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:17:42 INFO] Counselor: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Chief Executive Officer. Now, we are both working at ChatDev and we share a common interest in collaborating to successfully analyze a task assigned by a new customer.
Your main responsibilities include being an active decision-maker on users' demands and other key policy issues, leader, manager, and executor. Your decision-making role involves high-level decisions about policy and strategy; and your communicator role can involve speaking to the organization's management and employees.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Here is a conversation between two roles: Security Analyst: We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    function setUp() public override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));
        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);
        // Borrower decides to repay everything at mid-duration
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);
        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();
        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));
        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }
    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();
        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }
    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }
    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }
    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();
        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);
        assertLt(_collateralTokens, _collateralTokensNew);
    }
    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }
    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertEq(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_exchangeRateChanges();
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);
        helper_exchangeRateChanges();
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }
    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }
    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }
    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);
        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);
        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }
    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));
        _lender0.withdrawInterest(requestId);
        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);
        helper_exchangeRateChanges();
        _lender1.withdrawInterest(requestId);
        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }
    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }
    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;
    uint256 collateralToDeposit;
    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        helper_exchangeRateChanges();
        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL
        helper_exchangeRateChanges();
        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state
        helper_exchangeRateChanges();
        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);
        helper_exchangeRateChanges();
        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired
        helper_exchangeRateChanges();
        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);
        helper_exchangeRateChanges();
        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);
        helper_exchangeRateChanges();
        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.

Chief Executive Officer: We excel in generating innovative approaches and enhancements for Solidity smart contract code.
Here's a Solidity contract provided by the user: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;
import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';
import '../Helpers/PCLParent.t.sol';
contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;
    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;
    function setUp() public override {
        super.setUp();
        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);
        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));
        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));
        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;
        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));
        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');
        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);
        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);
        // Borrower decides to repay everything at mid-duration
        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);
        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }
    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();
        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));
        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }
    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();
        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }
    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }
    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }
    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }
    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }
    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }
    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();
        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }
    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        assertEq(_requiredCollateral, _requiredCollateralNew);
    }
    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);
        assertLt(_collateralTokens, _collateralTokensNew);
    }
    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }
    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertEq(_collateralRatio, _collateralRatioNew);
    }
    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);
        assertGt(_collateralRatio, _collateralRatioNew);
    }
    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        helper_exchangeRateChanges();
        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }
    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);
        helper_exchangeRateChanges();
        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));
        // Admin terminates the PCL
        admin.terminate(requestId);
        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }
    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);
        assertEq(_borrowableAmount, 0);
    }
    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);
        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }
    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }
    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }
    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }
    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);
        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }
    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }
    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();
        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }
    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);
        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }
    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);
        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);
        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);
        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));
        // Price fluctuations take place
        helper_exchangeRateChanges();
        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);
        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);
        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }
    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);
        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));
        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));
        _lender0.withdrawInterest(requestId);
        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);
        helper_exchangeRateChanges();
        _lender1.withdrawInterest(requestId);
        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }
    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }
    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;
    uint256 collateralToDeposit;
    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;
        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));
        helper_exchangeRateChanges();
        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL
        helper_exchangeRateChanges();
        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state
        helper_exchangeRateChanges();
        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);
        helper_exchangeRateChanges();
        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired
        helper_exchangeRateChanges();
        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);
        helper_exchangeRateChanges();
        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);
        helper_exchangeRateChanges();
        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);
        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }
    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
".
As the Security Analyst, our primary objective is to brainstorm potential improvements or related ideas for this specific contract code. Engage with me in a focused discussion to ensure we deliver the most impactful suggestion to the user.
Note that our conversation should be centered exclusively on the provided Solidity contract code, AND output results must only be English. Once we've collectively refined our suggestions and achieved unanimous agreement, the discussion should be concluded by any participant with a response starting with <INFO>, followed directly by the final idea or enhancement suggestion, e.g. "<INFO> Implementing a multi-sig wallet mechanism for added security in transactions".

Security Analyst: Let's Answer their Solidity smart contract ideas in the discussion without any other words, e.g., "A smart contract where we talk about Security: What functions the contract performs" 

[2024-27-08 09:17:46 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:17:46 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 25579
completion_tokens: 1
total_tokens: 25580
cost: $-1.000000


[2024-27-08 09:17:46 INFO] Chief Executive Officer: **Chief Executive Officer<->Counselor on : Reflection, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Counselor. Now, we share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your main responsibilities include asking what user and customer think and provide your valuable suggestions. 
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Security

[2024-27-08 09:17:46 INFO] **[Seminar Conclusion]**:

 Security

[2024-27-08 09:17:46 INFO] **[Seminar Conclusion]**:

 <INFO> Security

[2024-27-08 09:17:46 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:17:46 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 50 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral remains zero\n    function test_withdrawableCollateralIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, 0);\n    }\n\n    // Test 4: Withdraw collateral should revert\n    function test_withdrawCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawCollateral(requestId, 1, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral should revert\n    function test_withdrawAllCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An expired PCL cannot be cancelled\n    function test_borrowerCannotCancel() public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an expired PCL\n    function test_adminCanTerminatePCL() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 12: Borrowable amount remains zero\n    function test_borrowableAmountIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, 0);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An expired PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an expired PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt - 10000);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(_requestId, _requiredCollateral, false);\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 2);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(_requestId, currentDebt / 100);\n\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an expired pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an expired pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));\n\n        _lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        _lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since the state is expired\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0);\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_helperFunctionalitiesInExpiredState() public {\n        assert_helperFunctionalitiesInExpiredState(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:17:46 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:17:46 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:17:49 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:17:49 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17007
completion_tokens: 1
total_tokens: 17008
cost: $-1.000000


[2024-27-08 09:17:49 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

###

[2024-27-08 09:17:49 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:17:49 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 1

[2024-27-08 09:17:49 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 1, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:17:49 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:17:49 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:17:59 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:17:59 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8563
completion_tokens: 682
total_tokens: 9245
cost: $-1.000000


[2024-27-08 09:17:59 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Based on the provided Solidity smart contract code and its analysis, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement checks to prevent reentrancy attacks, particularly in functions that involve transferring tokens or updating balances. This could allow an attacker to exploit the contract by recursively calling functions before the state is updated.

2. **Integer Overflow/Underflow**: 
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to unexpected behavior if not properly handled, especially in complex calculations involving multiple variables.

3. **Access Control Issues**: 
   - There may be insufficient access control mechanisms in place for critical functions, such as terminating a pooled credit line or withdrawing funds. This could allow unauthorized users to execute sensitive operations.

4. **Lack of Input Validation**: 
   - Functions that accept user inputs (e.g., amounts for borrowing or collateral) do not have adequate validation checks. This could lead to unexpected behavior or exploitation by passing invalid values.

5. **Gas Limit and Loops**: 
   - The contract may contain loops that could exceed the gas limit, especially in functions that iterate over lenders or collateral tokens. This could lead to denial of service if the function cannot complete within the gas limit.

6. **Improper Error Handling**: 
   - The contract relies on revert statements for error handling but does not provide sufficient context or logging for errors, making it difficult to debug issues when they arise.

7. **Potential for Front-Running**: 
   - The contract may be susceptible to front-running attacks, where an attacker could exploit the timing of transactions to gain an advantage, particularly in functions that involve price or state changes.

8. **Uninitialized Variables**: 
   - Some state variables may not be properly initialized, leading to unpredictable behavior if they are accessed before being set.

### Comprehensive Analysis Report

The smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing concerns include the risk of reentrancy attacks, which could allow attackers to manipulate the contract state during token transfers. Additionally, while SafeMath is employed, the potential for integer overflow or underflow still exists in complex calculations.

Access control mechanisms are critical in ensuring that only authorized users can perform sensitive operations. The lack of robust input validation could lead to unexpected behavior, while loops that do not account for gas limits could result in denial of service.

Error handling is another area of concern, as insufficient logging can hinder debugging efforts. Furthermore, the potential for front-running attacks poses a significant risk, particularly in a financial context where timing is crucial.

To mitigate these vulnerabilities, it is recommended to implement the following measures:
- Introduce reentrancy guards in critical functions.
- Ensure all arithmetic operations are safeguarded against overflow/underflow.
- Implement strict access control using modifiers.
- Validate all user inputs rigorously.
- Optimize loops to prevent exceeding gas limits.
- Enhance error handling with detailed logging.
- Consider mechanisms to prevent front-running, such as transaction ordering or time-locks.

In conclusion, while the contract has a solid foundation, addressing these vulnerabilities is essential to ensure the security and integrity of the system. A thorough audit and testing phase should be conducted before deployment to mitigate risks effectively.

[2024-27-08 09:17:59 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code and its analysis, here is a succinct summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not implement checks to prevent reentrancy attacks, particularly in functions that involve transferring tokens or updating balances. This could allow an attacker to exploit the contract by recursively calling functions before the state is updated.

2. **Integer Overflow/Underflow**: 
   - Although the contract uses SafeMath, there may still be areas where arithmetic operations could lead to unexpected behavior if not properly handled, especially in complex calculations involving multiple variables.

3. **Access Control Issues**: 
   - There may be insufficient access control mechanisms in place for critical functions, such as terminating a pooled credit line or withdrawing funds. This could allow unauthorized users to execute sensitive operations.

4. **Lack of Input Validation**: 
   - Functions that accept user inputs (e.g., amounts for borrowing or collateral) do not have adequate validation checks. This could lead to unexpected behavior or exploitation by passing invalid values.

5. **Gas Limit and Loops**: 
   - The contract may contain loops that could exceed the gas limit, especially in functions that iterate over lenders or collateral tokens. This could lead to denial of service if the function cannot complete within the gas limit.

6. **Improper Error Handling**: 
   - The contract relies on revert statements for error handling but does not provide sufficient context or logging for errors, making it difficult to debug issues when they arise.

7. **Potential for Front-Running**: 
   - The contract may be susceptible to front-running attacks, where an attacker could exploit the timing of transactions to gain an advantage, particularly in functions that involve price or state changes.

8. **Uninitialized Variables**: 
   - Some state variables may not be properly initialized, leading to unpredictable behavior if they are accessed before being set.

### Comprehensive Analysis Report

The smart contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The most pressing concerns include the risk of reentrancy attacks, which could allow attackers to manipulate the contract state during token transfers. Additionally, while SafeMath is employed, the potential for integer overflow or underflow still exists in complex calculations.

Access control mechanisms are critical in ensuring that only authorized users can perform sensitive operations. The lack of robust input validation could lead to unexpected behavior, while loops that do not account for gas limits could result in denial of service.

Error handling is another area of concern, as insufficient logging can hinder debugging efforts. Furthermore, the potential for front-running attacks poses a significant risk, particularly in a financial context where timing is crucial.

To mitigate these vulnerabilities, it is recommended to implement the following measures:
- Introduce reentrancy guards in critical functions.
- Ensure all arithmetic operations are safeguarded against overflow/underflow.
- Implement strict access control using modifiers.
- Validate all user inputs rigorously.
- Optimize loops to prevent exceeding gas limits.
- Enhance error handling with detailed logging.
- Consider mechanisms to prevent front-running, such as transaction ordering or time-locks.

In conclusion, while the contract has a solid foundation, addressing these vulnerabilities is essential to ensure the security and integrity of the system. A thorough audit and testing phase should be conducted before deployment to mitigate risks effectively.

[2024-27-08 09:17:59 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:17:59 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 50 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral remains zero\n    function test_withdrawableCollateralIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, 0);\n    }\n\n    // Test 4: Withdraw collateral should revert\n    function test_withdrawCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawCollateral(requestId, 1, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral should revert\n    function test_withdrawAllCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An expired PCL cannot be cancelled\n    function test_borrowerCannotCancel() public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an expired PCL\n    function test_adminCanTerminatePCL() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 12: Borrowable amount remains zero\n    function test_borrowableAmountIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, 0);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An expired PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an expired PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt - 10000);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(_requestId, _requiredCollateral, false);\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 2);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(_requestId, currentDebt / 100);\n\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an expired pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an expired pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));\n\n        _lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        _lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since the state is expired\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0);\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_helperFunctionalitiesInExpiredState() public {\n        assert_helperFunctionalitiesInExpiredState(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:17:59 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:17:59 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:18:02 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:18:02 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17007
completion_tokens: 1
total_tokens: 17008
cost: $-1.000000


[2024-27-08 09:18:02 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

###

[2024-27-08 09:18:02 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:18:02 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 2

[2024-27-08 09:18:02 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 2, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:18:02 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:02 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:18:13 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:18:13 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8563
completion_tokens: 663
total_tokens: 9226
cost: $-1.000000


[2024-27-08 09:18:13 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Based on the provided Solidity smart contract code and its analysis, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not adequately protect against reentrancy attacks, particularly in functions that involve transferring tokens or changing state variables. This could allow an attacker to exploit the contract by re-entering a function before the previous execution is complete.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there may still be areas where arithmetic operations could lead to overflow or underflow if not handled correctly, especially in custom calculations or external calls.

3. **Access Control Issues**:
   - Certain functions may lack proper access control, allowing unauthorized users to execute sensitive operations. For example, functions that modify the state or transfer assets should be restricted to specific roles (e.g., admin, borrower).

4. **Improper Error Handling**:
   - The contract relies on `try/catch` for error handling in some cases, which may not cover all potential failure scenarios. This could lead to unexpected behavior or state inconsistencies.

5. **Lack of Input Validation**:
   - Functions that accept user input do not sufficiently validate the parameters, which could lead to unexpected behavior or exploitation. For example, checks on amounts being transferred or borrowed should be in place to prevent abuse.

6. **Gas Limit and Loops**:
   - The contract may contain loops that could exceed the gas limit, especially in functions that iterate over arrays or mappings. This could lead to failed transactions or denial of service.

7. **Timestamp Manipulation**:
   - The use of `block.timestamp` for critical logic (e.g., expiration checks) can be manipulated by miners, leading to potential exploitation. Alternative mechanisms should be considered for time-sensitive operations.

8. **Lack of Upgradeability Considerations**:
   - If the contract is intended to be upgradeable, there are no mechanisms in place to handle upgrades securely, which could lead to vulnerabilities in future iterations of the contract.

### Comprehensive Analysis Report

The `PCLExpiredStateCToken` contract exhibits several security vulnerabilities that could be exploited by malicious actors. The primary concerns include reentrancy attacks, which could allow attackers to manipulate the contract's state unexpectedly, and integer overflow/underflow risks, despite the use of `SafeMath`. 

Access control mechanisms are insufficient, potentially allowing unauthorized users to execute critical functions. Additionally, the contract's reliance on `try/catch` for error handling may not adequately address all failure scenarios, leading to inconsistent states.

Input validation is lacking, which could allow users to input malicious or unintended values, resulting in unexpected behavior. The potential for gas limit issues due to loops could also hinder contract functionality, especially under heavy load.

Timestamp manipulation poses a risk to the contract's time-sensitive logic, and the absence of upgradeability considerations could lead to challenges in maintaining the contract's security over time.

In conclusion, it is crucial to address these vulnerabilities through rigorous testing, implementing best practices for security, and ensuring that the contract adheres to established standards for Solidity development. Regular audits and updates should be conducted to maintain the integrity and security of the contract in the evolving blockchain landscape.

[2024-27-08 09:18:13 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code and its analysis, here is a summary of the identified security vulnerabilities:

### Summary of Security Vulnerabilities

1. **Reentrancy Vulnerability**: 
   - The contract does not adequately protect against reentrancy attacks, particularly in functions that involve transferring tokens or changing state variables. This could allow an attacker to exploit the contract by re-entering a function before the previous execution is complete.

2. **Integer Overflow/Underflow**:
   - Although the contract uses `SafeMath`, there may still be areas where arithmetic operations could lead to overflow or underflow if not handled correctly, especially in custom calculations or external calls.

3. **Access Control Issues**:
   - Certain functions may lack proper access control, allowing unauthorized users to execute sensitive operations. For example, functions that modify the state or transfer assets should be restricted to specific roles (e.g., admin, borrower).

4. **Improper Error Handling**:
   - The contract relies on `try/catch` for error handling in some cases, which may not cover all potential failure scenarios. This could lead to unexpected behavior or state inconsistencies.

5. **Lack of Input Validation**:
   - Functions that accept user input do not sufficiently validate the parameters, which could lead to unexpected behavior or exploitation. For example, checks on amounts being transferred or borrowed should be in place to prevent abuse.

6. **Gas Limit and Loops**:
   - The contract may contain loops that could exceed the gas limit, especially in functions that iterate over arrays or mappings. This could lead to failed transactions or denial of service.

7. **Timestamp Manipulation**:
   - The use of `block.timestamp` for critical logic (e.g., expiration checks) can be manipulated by miners, leading to potential exploitation. Alternative mechanisms should be considered for time-sensitive operations.

8. **Lack of Upgradeability Considerations**:
   - If the contract is intended to be upgradeable, there are no mechanisms in place to handle upgrades securely, which could lead to vulnerabilities in future iterations of the contract.

### Comprehensive Analysis Report

The `PCLExpiredStateCToken` contract exhibits several security vulnerabilities that could be exploited by malicious actors. The primary concerns include reentrancy attacks, which could allow attackers to manipulate the contract's state unexpectedly, and integer overflow/underflow risks, despite the use of `SafeMath`. 

Access control mechanisms are insufficient, potentially allowing unauthorized users to execute critical functions. Additionally, the contract's reliance on `try/catch` for error handling may not adequately address all failure scenarios, leading to inconsistent states.

Input validation is lacking, which could allow users to input malicious or unintended values, resulting in unexpected behavior. The potential for gas limit issues due to loops could also hinder contract functionality, especially under heavy load.

Timestamp manipulation poses a risk to the contract's time-sensitive logic, and the absence of upgradeability considerations could lead to challenges in maintaining the contract's security over time.

In conclusion, it is crucial to address these vulnerabilities through rigorous testing, implementing best practices for security, and ensuring that the contract adheres to established standards for Solidity development. Regular audits and updates should be conducted to maintain the integrity and security of the contract in the evolving blockchain landscape.

[2024-27-08 09:18:13 INFO] **[Execute Detail]**

execute SimplePhase:[ContractReviewComment] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:18:13 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Given the user's task and the brainstorming ideas provided: Task: "{task}". Ideas: "{ideas}". As the {assistant_role}, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability. For each vulnerability identified, use the following format: VULNERABILITY NAME or TYPE DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix. Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: " Analysis Complete." |
| **phase_name** | ContractReviewComment |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 50 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral remains zero\n    function test_withdrawableCollateralIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, 0);\n    }\n\n    // Test 4: Withdraw collateral should revert\n    function test_withdrawCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawCollateral(requestId, 1, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral should revert\n    function test_withdrawAllCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An expired PCL cannot be cancelled\n    function test_borrowerCannotCancel() public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an expired PCL\n    function test_adminCanTerminatePCL() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 12: Borrowable amount remains zero\n    function test_borrowableAmountIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, 0);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An expired PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an expired PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt - 10000);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(_requestId, _requiredCollateral, false);\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 2);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(_requestId, currentDebt / 100);\n\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an expired pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an expired pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));\n\n        _lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        _lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since the state is expired\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0);\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_helperFunctionalitiesInExpiredState() public {\n        assert_helperFunctionalitiesInExpiredState(requestId);\n    }\n}\n", 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:18:13 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Analyst |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:13 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Given the user's task and the brainstorming ideas provided:
Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
".
Ideas: " Security".
As the Security Analyst, your chief priority is to thoroughly inspect the given contract code and identify all potential vulnerabilities. It's crucial to ensure the contract's security and operability.
For each vulnerability identified, use the following format:
VULNERABILITY NAME or TYPE
```
DETAILED DESCRIPTION of the vulnerability, its potential impact, and recommended mitigation or fix.
```
Note that we must concentrate exclusively on identifying, describing, and suggesting fixes for vulnerabilities within the contract code. Once all vulnerabilities have been addressed, indicate the completion of your analysis by responding with: "<INFO> Analysis Complete."

[2024-27-08 09:18:18 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:18:18 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 17007
completion_tokens: 1
total_tokens: 17008
cost: $-1.000000


[2024-27-08 09:18:18 INFO] Security Analyst: **Security Analyst<->Solidity Programming Expert on : ContractReviewComment, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

###

[2024-27-08 09:18:18 INFO] **[Seminar Conclusion]**:

 ###

[2024-27-08 09:18:18 INFO] **[Execute Detail]**

execute SimplePhase:[BugsSummary] in ComposedPhase:[CodeReview], cycle 3

[2024-27-08 09:18:18 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **phase_prompt** | Below are the details of our smart contract codes and their corresponding analysis reports: Task: "{task}". As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report. |
| **phase_name** | BugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'cycle_num': 3, 'modification_conclusion': '', 'cycle_index': 3, 'task': '', 'ideas': ' Security'} |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |

[2024-27-08 09:18:18 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Solidity Programming Expert |
| **user_role_name** | Security Analyst |
| **assistant_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | No existed memory |
| **model_type** | ModelType.GPT_4_O_MINI |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:18 INFO] Security Analyst: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language.
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Below are the details of our smart contract codes and their corresponding analysis reports:
Task: "".
As per the provided analysis reports, please extract and succinctly summarize all the security vulnerabilities identified within the contract codes. The goal is to have a consolidated and clear overview of all security issues present. Conclude the summary with a comprehensive analysis report.

[2024-27-08 09:18:27 INFO] HTTP Request: POST https://api.openai.com/v1/chat/completions "HTTP/1.1 200 OK"
[2024-27-08 09:18:27 INFO] **[OpenAI_Usage_Info Receive]**
prompt_tokens: 8563
completion_tokens: 722
total_tokens: 9285
cost: $-1.000000


[2024-27-08 09:18:27 INFO] Solidity Programming Expert: **Solidity Programming Expert<->Security Analyst on : BugsSummary, turn 0**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Analyst. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer.
You can leverage your knowledge of Ethereum smart contracts and security best practices to throughly review the privoded vulnerable smart contracts and identify potential bugs and security vulnerablites
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Based on the provided Solidity smart contract code for `PCLExpiredStateCToken`, here is a summary of the security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or modify state variables could be susceptible to reentrancy attacks, especially in scenarios where external calls are made (e.g., transferring tokens).

2. **Integer Overflow/Underflow**:
   - While the contract uses SafeMath for arithmetic operations, it is important to ensure that all arithmetic operations are consistently wrapped in SafeMath functions to prevent overflow or underflow vulnerabilities, especially in older versions of Solidity.

3. **Access Control Issues**:
   - There may be insufficient access control mechanisms in place for critical functions, such as terminating the pooled credit line or modifying important parameters. This could allow unauthorized users to execute sensitive functions.

4. **Lack of Input Validation**:
   - Functions that accept user input (e.g., amounts for borrowing or collateral) do not have sufficient checks to validate the input values. This could lead to unexpected behavior or exploitation.

5. **Error Handling**:
   - The contract relies on revert messages for error handling, but some error messages may not be descriptive enough. This could hinder debugging and make it difficult to identify the cause of failures.

6. **State Variable Visibility**:
   - Some state variables are not explicitly marked with visibility modifiers (public, internal, private). This could lead to unintended access to sensitive data.

7. **Gas Limit Issues**:
   - Certain functions may consume a significant amount of gas, especially those that involve loops or complex calculations. This could lead to transaction failures if the gas limit is exceeded.

8. **Potential for Front-Running**:
   - The contract may be vulnerable to front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions with higher gas prices to gain an advantage.

9. **Lack of Event Logging**:
   - Important state changes and actions (e.g., collateral deposits, withdrawals, and repayments) may not emit events. This could lead to difficulties in tracking contract activity and auditing.

### Comprehensive Analysis Report:

The `PCLExpiredStateCToken` contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The absence of reentrancy guards, insufficient access control, and lack of input validation are particularly concerning, as they could lead to unauthorized access and manipulation of contract state. 

While the use of SafeMath mitigates the risk of integer overflow and underflow, it is crucial to ensure that all arithmetic operations are consistently safeguarded. Furthermore, the contract's reliance on revert messages for error handling may not provide enough clarity for debugging purposes.

To enhance the security posture of the contract, it is recommended to implement the following measures:

1. Introduce reentrancy guards on functions that modify state or transfer tokens.
2. Ensure all arithmetic operations are wrapped in SafeMath functions.
3. Implement robust access control mechanisms for sensitive functions.
4. Validate user inputs rigorously to prevent unexpected behavior.
5. Improve error messages for better clarity during debugging.
6. Explicitly define visibility modifiers for all state variables.
7. Optimize gas consumption in functions to prevent transaction failures.
8. Consider mechanisms to mitigate front-running risks.
9. Implement event logging for critical state changes and actions.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting users' assets and maintaining trust in the system.

[2024-27-08 09:18:27 INFO] **[Seminar Conclusion]**:

 Based on the provided Solidity smart contract code for `PCLExpiredStateCToken`, here is a summary of the security vulnerabilities identified within the contract:

### Summary of Security Vulnerabilities:

1. **Reentrancy Vulnerability**:
   - The contract does not implement any reentrancy guards. Functions that transfer tokens or modify state variables could be susceptible to reentrancy attacks, especially in scenarios where external calls are made (e.g., transferring tokens).

2. **Integer Overflow/Underflow**:
   - While the contract uses SafeMath for arithmetic operations, it is important to ensure that all arithmetic operations are consistently wrapped in SafeMath functions to prevent overflow or underflow vulnerabilities, especially in older versions of Solidity.

3. **Access Control Issues**:
   - There may be insufficient access control mechanisms in place for critical functions, such as terminating the pooled credit line or modifying important parameters. This could allow unauthorized users to execute sensitive functions.

4. **Lack of Input Validation**:
   - Functions that accept user input (e.g., amounts for borrowing or collateral) do not have sufficient checks to validate the input values. This could lead to unexpected behavior or exploitation.

5. **Error Handling**:
   - The contract relies on revert messages for error handling, but some error messages may not be descriptive enough. This could hinder debugging and make it difficult to identify the cause of failures.

6. **State Variable Visibility**:
   - Some state variables are not explicitly marked with visibility modifiers (public, internal, private). This could lead to unintended access to sensitive data.

7. **Gas Limit Issues**:
   - Certain functions may consume a significant amount of gas, especially those that involve loops or complex calculations. This could lead to transaction failures if the gas limit is exceeded.

8. **Potential for Front-Running**:
   - The contract may be vulnerable to front-running attacks, where a malicious actor could observe pending transactions and execute their own transactions with higher gas prices to gain an advantage.

9. **Lack of Event Logging**:
   - Important state changes and actions (e.g., collateral deposits, withdrawals, and repayments) may not emit events. This could lead to difficulties in tracking contract activity and auditing.

### Comprehensive Analysis Report:

The `PCLExpiredStateCToken` contract exhibits several security vulnerabilities that could potentially be exploited by malicious actors. The absence of reentrancy guards, insufficient access control, and lack of input validation are particularly concerning, as they could lead to unauthorized access and manipulation of contract state. 

While the use of SafeMath mitigates the risk of integer overflow and underflow, it is crucial to ensure that all arithmetic operations are consistently safeguarded. Furthermore, the contract's reliance on revert messages for error handling may not provide enough clarity for debugging purposes.

To enhance the security posture of the contract, it is recommended to implement the following measures:

1. Introduce reentrancy guards on functions that modify state or transfer tokens.
2. Ensure all arithmetic operations are wrapped in SafeMath functions.
3. Implement robust access control mechanisms for sensitive functions.
4. Validate user inputs rigorously to prevent unexpected behavior.
5. Improve error messages for better clarity during debugging.
6. Explicitly define visibility modifiers for all state variables.
7. Optimize gas consumption in functions to prevent transaction failures.
8. Consider mechanisms to mitigate front-running risks.
9. Implement event logging for critical state changes and actions.

By addressing these vulnerabilities, the contract can achieve a higher level of security and reliability, ultimately protecting users' assets and maintaining trust in the system.

[2024-27-08 09:18:31 INFO] System: **[chatting]**

| Parameter | Value |
| --- | --- |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **need_reflect** | False |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **phase_prompt** | Below are the details of our target smart contract codes and their associated test reports: Task: "{task}". Existing Test Reports: "{test_reports}" Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings. |
| **phase_name** | TestBugsSummary |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **chat_turn_limit** | 1 |
| **placeholders** | {'task': "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '../../../SublimeProxy.sol';\nimport '../../../PooledCreditLine/PooledCreditLine.sol';\nimport '../../../PooledCreditLine/LenderPool.sol';\nimport '../../../PriceOracle.sol';\nimport '../../../SavingsAccount/SavingsAccount.sol';\nimport '../../../yield/StrategyRegistry.sol';\nimport '../../../yield/NoYield.sol';\nimport '../../../yield/CompoundYield.sol';\nimport '../../../mocks/MockWETH.sol';\nimport '../../../mocks/MockCToken.sol';\nimport '../../../mocks/MockVerification2.sol';\nimport '../../../mocks/MockV3Aggregator.sol';\nimport '../../../mocks/MockToken.sol';\nimport '../../../interfaces/IPooledCreditLineDeclarations.sol';\nimport '../../../interfaces/ISavingsAccount.sol';\n\nimport '../Helpers/PCLParent.t.sol';\n\ncontract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {\n    using SafeMath for uint256;\n    using SafeMath for uint128;\n    using SafeERC20 for IERC20;\n\n    uint256 _borrowAssetDecimals;\n    uint256 _collateralAssetDecimals;\n    uint128 _collateralAssetPriceMin;\n    uint128 _borrowAssetPriceMin;\n    uint128 _collateralAssetPriceMax;\n    uint128 _borrowAssetPriceMax;\n    uint256 requestId;\n    uint256 _fromUserPoolTokenSupply;\n    uint256 _toUserPoolTokenSupply;\n    uint256 _fromUserPoolTokenSupplyNew;\n    uint256 _toUserPoolTokenSupplyNew;\n    uint256 _calculatedCurrentDebt;\n    uint256 _fetchedCurrentDebt;\n\n    function setUp() public override {\n        super.setUp();\n\n        lp = LenderPool(lenderPoolAddress);\n        pcl = PooledCreditLine(pooledCreditLineAddress);\n\n        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();\n        _borrowAssetPriceMin = uint128((1 * (10(_borrowAssetDecimals - 2))));\n        _borrowAssetPriceMax = uint128((10000 * (10_borrowAssetDecimals)));\n\n        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();\n        _collateralAssetPriceMin = uint128((1 * (10(_collateralAssetDecimals - 2))));\n        _collateralAssetPriceMax = uint128((1000 * (10_collateralAssetDecimals)));\n\n        request.borrowLimit = uint128(1_000_000 * (10ERC20(address(borrowAsset)).decimals()));\n        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);\n        request.collateralRatio = pcl.SCALING_FACTOR();\n        request.borrowAsset = address(borrowAsset);\n        request.collateralAsset = address(collateralAsset);\n        request.duration = 5000 days;\n        request.lenderVerifier = mockAdminVerifier1;\n        request.defaultGracePeriod = 50 days;\n        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;\n        request.collectionPeriod = 5 days;\n        request.minBorrowAmount = 90_000 * 10(ERC20(address(borrowAsset)).decimals());\n        request.borrowAssetStrategy = compoundYieldAddress;\n        request.collateralAssetStrategy = compoundYieldAddress;\n        request.borrowerVerifier = mockAdminVerifier2;\n        request.areTokensTransferable = true;\n\n        requestId = borrower.createRequest(request);\n        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));\n\n        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');\n\n        // Now the borrower finds out the collateral he is required to deposit\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n        // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(requestId, _requiredCollateral, false);\n\n        // Now the borrower calculates the borrowable amount\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);\n        // and borrows the borrowable amount\n        borrower.borrow(requestId, borrowableAmount);\n\n        // Borrower decides to repay everything at mid-duration\n\n        // Time travel to mid-duration\n        vm.warp(block.timestamp + request.duration / 2);\n        // Current Debt on the borrower\n        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(requestId, currentDebt / 2);\n\n        // Now we travel past the duration to the expiration period\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n    }\n\n    // Test 0: Test SetUp\n    function test_setUp() public {\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n\n        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();\n        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();\n\n        // Checking out what are the exchange rates\n        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));\n        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));\n\n        // Check the exchange rates of the borrow and collateral CTokens are non-zero\n        assertGt(_borrowCTokenExchangeRate, 0);\n        assertGt(_collateralCTokenExchangeRate, 0);\n    }\n\n    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations\n    function test_pclCannotBeStarted() public {\n        helper_exchangeRateChanges();\n\n        try borrower.start(requestId) {\n            revert('Cannot start an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:S1');\n        }\n    }\n\n    // Test 2: Collateral can be deposited\n    function test_collateralCanBeDeposited() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        helper_exchangeRateChanges();\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n        assertGt(pcl.depositedCollateralInShares(requestId), 0);\n    }\n\n    // Test 3: Withdrawable collateral remains zero\n    function test_withdrawableCollateralIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);\n        assertEq(_withdrawableCollateral, 0);\n    }\n\n    // Test 4: Withdraw collateral should revert\n    function test_withdrawCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawCollateral(requestId, 1, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WC1');\n        }\n    }\n\n    // Test 5: Withdraw all collateral should revert\n    function test_withdrawAllCollateralShouldNotBePossible() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        try borrower.withdrawAllCollateral(requestId, false) {\n            revert('Should not be able to withdraw');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:WAC1');\n        }\n    }\n\n    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations\n    function test_pclCanBeClosedIfPrincipalIsZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');\n    }\n\n    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations\n    function test_pclCannotBeClosedPrincipalIsNonZero() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        // Exchange rate fluctuations take place\n        helper_exchangeRateChanges();\n\n        try borrower.close(requestId) {\n            revert('Cannot close PCL when principal != 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:C2');\n        }\n    }\n\n    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply\n    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly\n    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);\n\n        assertEq(_requiredCollateral, _requiredCollateralNew);\n    }\n\n    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply\n    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);\n\n        assertLt(_collateralTokens, _collateralTokensNew);\n    }\n\n    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero\n    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        // We want to deposit collateral now\n        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);\n\n        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n        try pcl.calculateTotalCollateralTokens(requestId) {\n            revert('Total collateral tokens should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply\n    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);\n    }\n\n    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero\n    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertEq(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero\n    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try pcl.calculateCurrentCollateralRatio(requestId) {\n            revert('Collateral ratio should revert');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly\n    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {\n        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);\n\n        assertGt(_collateralRatio, _collateralRatioNew);\n    }\n\n    // Test 10: An expired PCL cannot be cancelled\n    function test_borrowerCannotCancel() public {\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        helper_exchangeRateChanges();\n\n        try borrower.cancelRequest(requestId) {\n            revert('Cannot cancel an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:CR1');\n        }\n    }\n\n    // Test 11: Admin should be able to terminate an expired PCL\n    function test_adminCanTerminatePCL() public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n\n        assertTrue(_principal != 0, 'Principal == 0');\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);\n\n        helper_exchangeRateChanges();\n\n        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));\n\n        // Admin terminates the PCL\n        admin.terminate(requestId);\n\n        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));\n        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));\n\n        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);\n        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);\n        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);\n    }\n\n    // Test 12: Borrowable amount remains zero\n    function test_borrowableAmountIsZero() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);\n\n        assertEq(_borrowableAmount, 0);\n    }\n\n    // Test 13: Borrower can repay\n    function test_borrowerCanRepay() public {\n        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);\n\n        // Transferring collateral tokens to the borrower\n        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);\n        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);\n\n        helper_exchangeRateChanges();\n        admin.transferToken(address(borrowAsset), address(borrower), 1);\n        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);\n        borrower.repay(requestId, 1);\n    }\n\n    // Test 14: An expired PCL cannot be liquidated if principal == 0\n    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {\n        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal != 0, 'Principal == 0');\n\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay entire debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt);\n\n        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);\n        assertTrue(_principal == 0, 'Principal != 0');\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_exchangeRateChanges();\n\n        // _lender0 tries to liquidate the PCL\n        try _lender0.liquidate(requestId, _withdraw) {\n            revert('Cannot liquidate an expired PCL with principal == 0');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L1');\n        }\n    }\n\n    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt - 10000);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(borrowCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'PCL:L3');\n        }\n    }\n\n    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero\n    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {\n        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);\n        // Borrower decides to repay partial debt\n        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);\n        borrower.repay(requestId, _currentDebt / 2);\n\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        helper_decreaseExchangeRateToZero(collateralCTokenAddress);\n\n        try _lender0.liquidate(requestId, false) {\n            revert('Cannot liquidate an expired PCL with CR &gt;= ICR');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'CY:GTFS1');\n        }\n    }\n\n    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly\n    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {\n        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);\n        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);\n        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);\n        borrower.depositCollateral(_requestId, _requiredCollateral, false);\n\n        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);\n        borrower.borrow(_requestId, borrowableAmount);\n\n        vm.warp(block.timestamp + request.duration / 2);\n        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);\n        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);\n        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);\n        borrower.repay(_requestId, currentDebt / 100);\n\n        vm.warp(block.timestamp + 100 + request.duration / 2);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');\n        helper_increaseExchangeRateSlowly(collateralCTokenAddress);\n        _lender0.liquidate(_requestId, false);\n        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);\n    }\n\n    // Test 15: Lenders cannot withdraw liquidation from an expired pcl\n    function test_lendersCannotWithdrawLiquidation() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawTokensAfterLiquidation(requestId) {\n            revert('Cannot withdraw liquidation from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWLC1');\n        }\n    }\n\n    // Test 16: Lenders cannot withdraw liquidity from an expired pcl\n    function test_lendersCannotWithdrawLiquidity() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        helper_exchangeRateChanges();\n\n        try _lender0.withdrawLiquidity(requestId) {\n            revert('Cannot withdraw liquidity from an expired PCL');\n        } catch Error(string memory reason) {\n            assertEq(reason, 'LP:IWL3');\n        }\n    }\n\n    // Test 17: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);\n\n        //Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, 0);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == 0);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));\n    }\n\n    // Test 17.1: Pool token transfers should be possible in an expired PCL\n    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {\n        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);\n        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);\n        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);\n        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n        assertGt(lender2PoolTokenBalance, 0);\n        assertGt(lender3PoolTokenBalance, 0);\n\n        // Lender0 transfers pool tokens to lender1\n        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);\n\n        // Checking the transfer took place or not\n        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);\n        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);\n\n        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);\n        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));\n\n        // Price fluctuations take place\n        helper_exchangeRateChanges();\n\n        // Lender2 transfers pool tokens to lender3\n        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);\n\n        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);\n        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);\n\n        // Checking whether the transfer took place or not\n        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);\n        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));\n    }\n\n    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations\n    function test_lendersCanWithdrawInterest() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);\n\n        // Ensuring that these lenders indeed had lent something\n        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);\n        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));\n\n        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);\n        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));\n\n        assertGt(lender0PoolTokenBalance, 0);\n        assertGt(lender1PoolTokenBalance, 0);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));\n\n        _lender0.withdrawInterest(requestId);\n\n        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));\n        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);\n\n        helper_exchangeRateChanges();\n\n        _lender1.withdrawInterest(requestId);\n\n        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));\n        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);\n    }\n\n    // Test 18.1: Interest that can be withdrawn increases\n    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {\n        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);\n\n        // Fetching the interest owed to lenders\n        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        helper_increaseExchangeRateSteeply(borrowCTokenAddress);\n\n        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));\n        assertLt(lender0InterestOwed, lender0InterestOwedNew);\n    }\n\n    uint256 _principal;\n    uint256 _currentCR1;\n    uint256 _currentCR2;\n    uint256 _currentCR3;\n    uint256 _principalWithdrawable;\n    uint256 _withdrawableCollateral;\n    uint256 _currentDebt;\n    uint256 _borrowable;\n    uint256 _totalCollateral;\n    uint256 _equivalentCollateral;\n    uint256 _interestAccrued;\n\n    uint256 collateralToDeposit;\n\n    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n\n        PCLUser _lender = PCLUser(lenders[0].lenderAddress);\n        PCLUser _borrower = borrower;\n\n        // 1. calculateCurrentCollateralRatio\n        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);\n        assertLt(_currentCR2, uint256(-1));\n\n        helper_exchangeRateChanges();\n\n        // 2. calculatePrincipalWithdrawable\n        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));\n        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL\n\n        helper_exchangeRateChanges();\n\n        // 3. withdrawableCollateral\n        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);\n        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state\n\n        helper_exchangeRateChanges();\n\n        // 4. calculateCurrentDebt\n        _currentDebt = _borrower.calculateCurrentDebt(_id);\n        assertGt(_currentDebt, 0);\n\n        helper_exchangeRateChanges();\n\n        // 5. calculateBorrowableAmount\n        _borrowable = _borrower.calculateBorrowableAmount(_id);\n        assertEq(_borrowable, 0); // Since the state is expired\n\n        helper_exchangeRateChanges();\n\n        // 6. calculateTotalCollateralTokens\n        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);\n        assertGt(_totalCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 7. collateralTokensToLiquidate\n        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));\n        assertGt(_equivalentCollateral, 0);\n\n        helper_exchangeRateChanges();\n\n        // 8. calculateInterestAccrued\n        _interestAccrued = _borrower.calculateInterestAccrued(_id);\n        assertGt(_interestAccrued, 0);\n\n        helper_exchangeRateChanges();\n        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);\n    }\n\n    function test_helperFunctionalitiesInExpiredState() public {\n        assert_helperFunctionalitiesInExpiredState(requestId);\n    }\n}\n", 'ideas': ' Security', 'test_reports': 'The software run successfully without errors.', 'exist_bugs_flag': False} |

[2024-27-08 09:18:31 INFO] System: **[RolePlaying]**

| Parameter | Value |
| --- | --- |
| **assistant_role_name** | Security Testing Engineer |
| **user_role_name** | Solidity Programming Expert |
| **assistant_role_prompt** | {chatdev_prompt} You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer. Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures Here is a new customer's task: {task}. |
| **user_role_prompt** | {chatdev_prompt} You are Solidity Programming Expert. Now, we are both working at ChatDev and share a common interest in collaborating to successfully execute a marketing strategy for a new customer. You can analyze the code structure, logic, and implementation details of the contracts. You have extensive computing and coding experience in Solidity programming language. Here is a new customer's task: {task}. |
| **task_prompt** | // SPDX-License-Identifier: MIT pragma solidity 0.7.6; pragma abicoder v2; import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol'; import '@openzeppelin/contracts/math/SafeMath.sol'; import '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import '../../../SublimeProxy.sol'; import '../../../PooledCreditLine/PooledCreditLine.sol'; import '../../../PooledCreditLine/LenderPool.sol'; import '../../../PriceOracle.sol'; import '../../../SavingsAccount/SavingsAccount.sol'; import '../../../yield/StrategyRegistry.sol'; import '../../../yield/NoYield.sol'; import '../../../yield/CompoundYield.sol'; import '../../../mocks/MockWETH.sol'; import '../../../mocks/MockCToken.sol'; import '../../../mocks/MockVerification2.sol'; import '../../../mocks/MockV3Aggregator.sol'; import '../../../mocks/MockToken.sol'; import '../../../interfaces/IPooledCreditLineDeclarations.sol'; import '../../../interfaces/ISavingsAccount.sol'; import '../Helpers/PCLParent.t.sol'; contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {     using SafeMath for uint256;     using SafeMath for uint128;     using SafeERC20 for IERC20; uint256 _borrowAssetDecimals; uint256 _collateralAssetDecimals; uint128 _collateralAssetPriceMin; uint128 _borrowAssetPriceMin; uint128 _collateralAssetPriceMax; uint128 _borrowAssetPriceMax; uint256 requestId; uint256 _fromUserPoolTokenSupply; uint256 _toUserPoolTokenSupply; uint256 _fromUserPoolTokenSupplyNew; uint256 _toUserPoolTokenSupplyNew; uint256 _calculatedCurrentDebt; uint256 _fetchedCurrentDebt;  function setUp() public override {     super.setUp();      lp = LenderPool(lenderPoolAddress);     pcl = PooledCreditLine(pooledCreditLineAddress);      _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();     _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));     _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));      _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();     _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));     _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));      request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));     request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);     request.collateralRatio = pcl.SCALING_FACTOR();     request.borrowAsset = address(borrowAsset);     request.collateralAsset = address(collateralAsset);     request.duration = 5000 days;     request.lenderVerifier = mockAdminVerifier1;     request.defaultGracePeriod = 50 days;     request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;     request.collectionPeriod = 5 days;     request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());     request.borrowAssetStrategy = compoundYieldAddress;     request.collateralAssetStrategy = compoundYieldAddress;     request.borrowerVerifier = mockAdminVerifier2;     request.areTokensTransferable = true;      requestId = borrower.createRequest(request);     assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));      (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');      // Now the borrower finds out the collateral he is required to deposit     uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);     // &amp; deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(requestId, _requiredCollateral, false);      // Now the borrower calculates the borrowable amount     uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);     // and borrows the borrowable amount     borrower.borrow(requestId, borrowableAmount);      // Borrower decides to repay everything at mid-duration      // Time travel to mid-duration     vm.warp(block.timestamp + request.duration / 2);     // Current Debt on the borrower     uint256 currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(requestId, currentDebt / 2);      // Now we travel past the duration to the expiration period     vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired'); }  // Test 0: Test SetUp function test_setUp() public {     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');      uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();     uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();      // Checking out what are the exchange rates     log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));     log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));      // Check the exchange rates of the borrow and collateral CTokens are non-zero     assertGt(_borrowCTokenExchangeRate, 0);     assertGt(_collateralCTokenExchangeRate, 0); }  // Test 1: An expired PCL cannot be started even with exchange rate fluctuations function test_pclCannotBeStarted() public {     helper_exchangeRateChanges();      try borrower.start(requestId) {         revert('Cannot start an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:S1');     } }  // Test 2: Collateral can be deposited function test_collateralCanBeDeposited() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     helper_exchangeRateChanges();     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);     assertGt(pcl.depositedCollateralInShares(requestId), 0); }  // Test 3: Withdrawable collateral remains zero function test_withdrawableCollateralIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);     assertEq(_withdrawableCollateral, 0); }  // Test 4: Withdraw collateral should revert function test_withdrawCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawCollateral(requestId, 1, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WC1');     } }  // Test 5: Withdraw all collateral should revert function test_withdrawAllCollateralShouldNotBePossible() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     try borrower.withdrawAllCollateral(requestId, false) {         revert('Should not be able to withdraw');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:WAC1');     } }  // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations function test_pclCanBeClosedIfPrincipalIsZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed'); }  // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations function test_pclCannotBeClosedPrincipalIsNonZero() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      // Exchange rate fluctuations take place     helper_exchangeRateChanges();      try borrower.close(requestId) {         revert('Cannot close PCL when principal != 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:C2');     } }  // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);      assertEq(_requiredCollateral, _requiredCollateralNew); }  // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);      assertLt(_collateralTokens, _collateralTokensNew); }  // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      // We want to deposit collateral now     borrower.depositCollateral(requestId, _minimumCollateralRequired, false);      uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);     try pcl.calculateTotalCollateralTokens(requestId) {         revert('Total collateral tokens should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, _collateralRatioNew); }  // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt); }  // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertEq(_collateralRatio, _collateralRatioNew); }  // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try pcl.calculateCurrentCollateralRatio(requestId) {         revert('Collateral ratio should revert');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {     uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);      assertGt(_collateralRatio, _collateralRatioNew); }  // Test 10: An expired PCL cannot be cancelled function test_borrowerCannotCancel() public {     (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      helper_exchangeRateChanges();      try borrower.cancelRequest(requestId) {         revert('Cannot cancel an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:CR1');     } }  // Test 11: Admin should be able to terminate an expired PCL function test_adminCanTerminatePCL() public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);      assertTrue(_principal != 0, 'Principal == 0');     assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);      helper_exchangeRateChanges();      uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));      // Admin terminates the PCL     admin.terminate(requestId);      uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));     uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));      assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);     assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);     assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0); }  // Test 12: Borrowable amount remains zero function test_borrowableAmountIsZero() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);      assertEq(_borrowableAmount, 0); }  // Test 13: Borrower can repay function test_borrowerCanRepay() public {     uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);      // Transferring collateral tokens to the borrower     admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);     borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);      helper_exchangeRateChanges();     admin.transferToken(address(borrowAsset), address(borrower), 1);     borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);     borrower.repay(requestId, 1); }  // Test 14: An expired PCL cannot be liquidated if principal == 0 function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {     (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal != 0, 'Principal == 0');      uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay entire debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt);      (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);     assertTrue(_principal == 0, 'Principal != 0');      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_exchangeRateChanges();      // _lender0 tries to liquidate the PCL     try _lender0.liquidate(requestId, _withdraw) {         revert('Cannot liquidate an expired PCL with principal == 0');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L1');     } }  // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt - 10000);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(borrowCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'PCL:L3');     } }  // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {     uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);     // Borrower decides to repay partial debt     admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);     borrower.repay(requestId, _currentDebt / 2);      PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     helper_decreaseExchangeRateToZero(collateralCTokenAddress);      try _lender0.liquidate(requestId, false) {         revert('Cannot liquidate an expired PCL with CR &gt;= ICR');     } catch Error(string memory reason) {         assertEq(reason, 'CY:GTFS1');     } }  // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {     (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);     admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);     borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);     borrower.depositCollateral(_requestId, _requiredCollateral, false);      uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);     borrower.borrow(_requestId, borrowableAmount);      vm.warp(block.timestamp + request.duration / 2);     uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);     admin.transferToken(address(borrowAsset), address(borrower), currentDebt);     borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);     borrower.repay(_requestId, currentDebt / 100);      vm.warp(block.timestamp + 100 + request.duration / 2);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');     helper_increaseExchangeRateSlowly(collateralCTokenAddress);     _lender0.liquidate(_requestId, false);     assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED); }  // Test 15: Lenders cannot withdraw liquidation from an expired pcl function test_lendersCannotWithdrawLiquidation() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawTokensAfterLiquidation(requestId) {         revert('Cannot withdraw liquidation from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWLC1');     } }  // Test 16: Lenders cannot withdraw liquidity from an expired pcl function test_lendersCannotWithdrawLiquidity() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      helper_exchangeRateChanges();      try _lender0.withdrawLiquidity(requestId) {         revert('Cannot withdraw liquidity from an expired PCL');     } catch Error(string memory reason) {         assertEq(reason, 'LP:IWL3');     } }  // Test 17: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossibleEntireBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);      //Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, 0);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == 0);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance)); }  // Test 17.1: Pool token transfers should be possible in an expired PCL function test_poolTokenTransfersShouldBePossiblePartialBalance() public {     PCLUser lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser lender1 = PCLUser(lenders[1].lenderAddress);     PCLUser lender2 = PCLUser(lenders[2].lenderAddress);     PCLUser lender3 = PCLUser(lenders[3].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);     uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);     assertGt(lender2PoolTokenBalance, 0);     assertGt(lender3PoolTokenBalance, 0);      // Lender0 transfers pool tokens to lender1     lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);      // Checking the transfer took place or not     uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);     uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);      assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);     assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));      // Price fluctuations take place     helper_exchangeRateChanges();      // Lender2 transfers pool tokens to lender3     lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);      uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);     uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);      // Checking whether the transfer took place or not     assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);     assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance)); }  // Test 18: Interest can be withdrawn amidst exchange rate fluctuations function test_lendersCanWithdrawInterest() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);     PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);      // Ensuring that these lenders indeed had lent something     uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);     uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));      uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);     uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));      assertGt(lender0PoolTokenBalance, 0);     assertGt(lender1PoolTokenBalance, 0);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));      _lender0.withdrawInterest(requestId);      uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));     assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);      helper_exchangeRateChanges();      _lender1.withdrawInterest(requestId);      uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));     assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed); }  // Test 18.1: Interest that can be withdrawn increases function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {     PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);      // Fetching the interest owed to lenders     uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     helper_increaseExchangeRateSteeply(borrowCTokenAddress);      uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));     assertLt(lender0InterestOwed, lender0InterestOwedNew); }  uint256 _principal; uint256 _currentCR1; uint256 _currentCR2; uint256 _currentCR3; uint256 _principalWithdrawable; uint256 _withdrawableCollateral; uint256 _currentDebt; uint256 _borrowable; uint256 _totalCollateral; uint256 _equivalentCollateral; uint256 _interestAccrued;  uint256 collateralToDeposit;  function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);      PCLUser _lender = PCLUser(lenders[0].lenderAddress);     PCLUser _borrower = borrower;      // 1. calculateCurrentCollateralRatio     _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);     assertLt(_currentCR2, uint256(-1));      helper_exchangeRateChanges();      // 2. calculatePrincipalWithdrawable     _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));     assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL      helper_exchangeRateChanges();      // 3. withdrawableCollateral     _withdrawableCollateral = _borrower.withdrawableCollateral(_id);     assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state      helper_exchangeRateChanges();      // 4. calculateCurrentDebt     _currentDebt = _borrower.calculateCurrentDebt(_id);     assertGt(_currentDebt, 0);      helper_exchangeRateChanges();      // 5. calculateBorrowableAmount     _borrowable = _borrower.calculateBorrowableAmount(_id);     assertEq(_borrowable, 0); // Since the state is expired      helper_exchangeRateChanges();      // 6. calculateTotalCollateralTokens     _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);     assertGt(_totalCollateral, 0);      helper_exchangeRateChanges();      // 7. collateralTokensToLiquidate     _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));     assertGt(_equivalentCollateral, 0);      helper_exchangeRateChanges();      // 8. calculateInterestAccrued     _interestAccrued = _borrower.calculateInterestAccrued(_id);     assertGt(_interestAccrued, 0);      helper_exchangeRateChanges();     assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED); }  function test_helperFunctionalitiesInExpiredState() public {     assert_helperFunctionalitiesInExpiredState(requestId); }  } |
| **with_task_specify** | False |
| **memory** | None |
| **model_type** | ModelType.GPT_3_5_TURBO |
| **background_prompt** | We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments. |

[2024-27-08 09:18:31 INFO] Solidity Programming Expert: **[Start Chat]**

[We are a specialized team that audits Solidity smart contracts using an advanced multi-agent system. Our approach combines the expertise of project management, smart contract counseling, auditing, and Solidity programming to deliver comprehensive and reliable contract assessments.
You are Security Testing Engineer. we are both working at ChatDev. We share a common interest in collaborating to successfully complete a task assigned by a new customer.
Your can simulate various attack scenarios, conduct security testing, and perform code audits to identify vulnerablities and weaknesses in the smart contracts. This inculde analyzing potential exploit paths, assessing the resilience of the contract to common attack vectorsm and suggesting remediation measures
Here is a new customer's task: // SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
.]

Below are the details of our target smart contract codes and their associated test reports:

Task: "// SPDX-License-Identifier: MIT
pragma solidity 0.7.6;
pragma abicoder v2;

import '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';
import '@openzeppelin/contracts/math/SafeMath.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';

import '../../../SublimeProxy.sol';
import '../../../PooledCreditLine/PooledCreditLine.sol';
import '../../../PooledCreditLine/LenderPool.sol';
import '../../../PriceOracle.sol';
import '../../../SavingsAccount/SavingsAccount.sol';
import '../../../yield/StrategyRegistry.sol';
import '../../../yield/NoYield.sol';
import '../../../yield/CompoundYield.sol';
import '../../../mocks/MockWETH.sol';
import '../../../mocks/MockCToken.sol';
import '../../../mocks/MockVerification2.sol';
import '../../../mocks/MockV3Aggregator.sol';
import '../../../mocks/MockToken.sol';
import '../../../interfaces/IPooledCreditLineDeclarations.sol';
import '../../../interfaces/ISavingsAccount.sol';

import '../Helpers/PCLParent.t.sol';

contract PCLExpiredStateCToken is IPooledCreditLineDeclarations, PCLParent {
    using SafeMath for uint256;
    using SafeMath for uint128;
    using SafeERC20 for IERC20;

    uint256 _borrowAssetDecimals;
    uint256 _collateralAssetDecimals;
    uint128 _collateralAssetPriceMin;
    uint128 _borrowAssetPriceMin;
    uint128 _collateralAssetPriceMax;
    uint128 _borrowAssetPriceMax;
    uint256 requestId;
    uint256 _fromUserPoolTokenSupply;
    uint256 _toUserPoolTokenSupply;
    uint256 _fromUserPoolTokenSupplyNew;
    uint256 _toUserPoolTokenSupplyNew;
    uint256 _calculatedCurrentDebt;
    uint256 _fetchedCurrentDebt;

    function setUp() public override {
        super.setUp();

        lp = LenderPool(lenderPoolAddress);
        pcl = PooledCreditLine(pooledCreditLineAddress);

        _borrowAssetDecimals = ERC20(address(borrowAsset)).decimals();
        _borrowAssetPriceMin = uint128((1 * (10**(_borrowAssetDecimals - 2))));
        _borrowAssetPriceMax = uint128((10000 * (10**_borrowAssetDecimals)));

        _collateralAssetDecimals = ERC20(address(collateralAsset)).decimals();
        _collateralAssetPriceMin = uint128((1 * (10**(_collateralAssetDecimals - 2))));
        _collateralAssetPriceMax = uint128((1000 * (10**_collateralAssetDecimals)));

        request.borrowLimit = uint128(1_000_000 * (10**ERC20(address(borrowAsset)).decimals()));
        request.borrowRate = uint128((1 * pcl.SCALING_FACTOR()) / 1e2);
        request.collateralRatio = pcl.SCALING_FACTOR();
        request.borrowAsset = address(borrowAsset);
        request.collateralAsset = address(collateralAsset);
        request.duration = 5000 days;
        request.lenderVerifier = mockAdminVerifier1;
        request.defaultGracePeriod = 50 days;
        request.gracePenaltyRate = (10 * pcl.SCALING_FACTOR()) / 1e2;
        request.collectionPeriod = 5 days;
        request.minBorrowAmount = 90_000 * 10**(ERC20(address(borrowAsset)).decimals());
        request.borrowAssetStrategy = compoundYieldAddress;
        request.collateralAssetStrategy = compoundYieldAddress;
        request.borrowerVerifier = mockAdminVerifier2;
        request.areTokensTransferable = true;

        requestId = borrower.createRequest(request);
        assertEq(uint256(pcl.getStatusAndUpdate(requestId)), uint256(1));

        (requestId, numLenders) = goToActiveStage(10, request.borrowLimit);

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.ACTIVE, '!Active');

        // Now the borrower finds out the collateral he is required to deposit
        uint256 _requiredCollateral = borrower.getRequiredCollateral(requestId, request.borrowLimit);
        // & deposits the required collateral (this involves getting the collateral from the admin and giving allowance to the PCL)
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(requestId, _requiredCollateral, false);

        // Now the borrower calculates the borrowable amount
        uint256 borrowableAmount = borrower.calculateBorrowableAmount(requestId);
        // and borrows the borrowable amount
        borrower.borrow(requestId, borrowableAmount);

        // Borrower decides to repay everything at mid-duration

        // Time travel to mid-duration
        vm.warp(block.timestamp + request.duration / 2);
        // Current Debt on the borrower
        uint256 currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(requestId, currentDebt / 2);

        // Now we travel past the duration to the expiration period
        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
    }

    // Test 0: Test SetUp
    function test_setUp() public {
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');

        uint256 _borrowCTokenExchangeRate = MockCToken(borrowCTokenAddress).exchangeRateCurrent();
        uint256 _collateralCTokenExchangeRate = MockCToken(collateralCTokenAddress).exchangeRateCurrent();

        // Checking out what are the exchange rates
        log_named_int('Borrow CToken Exchange Rate', int256(_borrowCTokenExchangeRate));
        log_named_int('Collateral CToken Exchange Rate', int256(_collateralCTokenExchangeRate));

        // Check the exchange rates of the borrow and collateral CTokens are non-zero
        assertGt(_borrowCTokenExchangeRate, 0);
        assertGt(_collateralCTokenExchangeRate, 0);
    }

    // Test 1: An expired PCL cannot be started even with exchange rate fluctuations
    function test_pclCannotBeStarted() public {
        helper_exchangeRateChanges();

        try borrower.start(requestId) {
            revert('Cannot start an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:S1');
        }
    }

    // Test 2: Collateral can be deposited
    function test_collateralCanBeDeposited() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        helper_exchangeRateChanges();
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);
        assertGt(pcl.depositedCollateralInShares(requestId), 0);
    }

    // Test 3: Withdrawable collateral remains zero
    function test_withdrawableCollateralIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _withdrawableCollateral = pcl.withdrawableCollateral(requestId);
        assertEq(_withdrawableCollateral, 0);
    }

    // Test 4: Withdraw collateral should revert
    function test_withdrawCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawCollateral(requestId, 1, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WC1');
        }
    }

    // Test 5: Withdraw all collateral should revert
    function test_withdrawAllCollateralShouldNotBePossible() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        try borrower.withdrawAllCollateral(requestId, false) {
            revert('Should not be able to withdraw');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:WAC1');
        }
    }

    // Test 6: An expired PCL (with principal == 0) can be closed even with exchange rate fluctuations
    function test_pclCanBeClosedIfPrincipalIsZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.CLOSED, '!Closed');
    }

    // Test 6.1: An expired PCL (with principal != 0) cannot be closed even with exchange rate fluctuations
    function test_pclCannotBeClosedPrincipalIsNonZero() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        // Exchange rate fluctuations take place
        helper_exchangeRateChanges();

        try borrower.close(requestId) {
            revert('Cannot close PCL when principal != 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:C2');
        }
    }

    // Test 7: Required collateral remains same if collateral CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.1: Required collateral remains same if borrow CToken exchange rate increases steeply
    function test_requiredCollateralRemainsSameIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.2: Required collateral remains same if borrow CToken exchange rate decreases to zero
    function test_requiredCollateralRemainSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.3: Required collateral remains same if collateral CToken exchange rate decreases to zero
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 7.4: Required collateral remains same if collateral CToken exchange rate increases very slowly
    function test_requiredCollateralRemainsSameIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _requiredCollateral = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _requiredCollateralNew = pcl.getRequiredCollateral(requestId, request.borrowLimit / 2);

        assertEq(_requiredCollateral, _requiredCollateralNew);
    }

    // Test 8: Collateral tokens increases if collateral CToken exchange rate increases steeply
    function test_totalCollateralTokensIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralTokensNew = pcl.calculateTotalCollateralTokens(requestId);

        assertLt(_collateralTokens, _collateralTokensNew);
    }

    // Test 8.1: Collateral tokens reverts if collateral CToken exchange rate decreases to zero
    function test_totalCollateralTokensRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        // We want to deposit collateral now
        borrower.depositCollateral(requestId, _minimumCollateralRequired, false);

        uint256 _collateralTokens = pcl.calculateTotalCollateralTokens(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);
        try pcl.calculateTotalCollateralTokens(requestId) {
            revert('Total collateral tokens should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9: Collateral ratio increases if collateral CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.1: Collateral ratio increases if borrow CToken exchange rate increases steeply
    function test_collateralRatioIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        uint256 _currentDebt = pcl.calculateCurrentDebt(requestId);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 _interestAccrued = pcl.calculateInterestAccrued(requestId);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertLt(_collateralRatio, (_collateralRatioNew * (_currentDebt + _interestAccrued)) / _currentDebt);
    }

    // Test 9.2: Collateral ratio remains same if borrow CToken exchange rate decreases to zero
    function test_collateralRatioRemaisSameIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertEq(_collateralRatio, _collateralRatioNew);
    }

    // Test 9.3: Collateral ratio reverts if collateral CToken exchange rate decreases to zero
    function test_collateralRatioRevertsIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try pcl.calculateCurrentCollateralRatio(requestId) {
            revert('Collateral ratio should revert');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 9.4: Collateral ratio decreases if collateral CToken exchange rate increases very slowly
    function test_collateralRatioDecreasesIfCollateralCTokenExchangeRateIncreasesSlowly() public {
        uint256 _collateralRatio = pcl.calculateCurrentCollateralRatio(requestId);
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        uint256 _collateralRatioNew = pcl.calculateCurrentCollateralRatio(requestId);

        assertGt(_collateralRatio, _collateralRatioNew);
    }

    // Test 10: An expired PCL cannot be cancelled
    function test_borrowerCannotCancel() public {
        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        helper_exchangeRateChanges();

        try borrower.cancelRequest(requestId) {
            revert('Cannot cancel an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:CR1');
        }
    }

    // Test 11: Admin should be able to terminate an expired PCL
    function test_adminCanTerminatePCL() public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);

        assertTrue(_principal != 0, 'Principal == 0');
        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.EXPIRED);

        helper_exchangeRateChanges();

        uint256 _adminBorrowTokenBalancePreTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePreTerminate = collateralAsset.balanceOf(address(admin));

        // Admin terminates the PCL
        admin.terminate(requestId);

        uint256 _adminBorrowTokenBalancePostTerminate = borrowAsset.balanceOf(address(admin));
        uint256 _adminCollateralTokenBalancePostTerminate = collateralAsset.balanceOf(address(admin));

        assertTrue(pcl.getStatusAndUpdate(requestId) == PooledCreditLineStatus.NOT_CREATED);
        assertGt((_adminCollateralTokenBalancePostTerminate - _adminCollateralTokenBalancePreTerminate), 0);
        assertGt((_adminBorrowTokenBalancePostTerminate - _adminBorrowTokenBalancePreTerminate), 0);
    }

    // Test 12: Borrowable amount remains zero
    function test_borrowableAmountIsZero() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        uint256 _borrowableAmount = pcl.calculateBorrowableAmount(requestId);

        assertEq(_borrowableAmount, 0);
    }

    // Test 13: Borrower can repay
    function test_borrowerCanRepay() public {
        uint256 _minimumCollateralRequired = borrower.getRequiredCollateral(requestId, request.borrowLimit);

        // Transferring collateral tokens to the borrower
        admin.transferToken(address(collateralAsset), address(borrower), _minimumCollateralRequired);
        borrower.setAllowance(address(pcl), address(collateralAsset), type(uint256).max);

        helper_exchangeRateChanges();
        admin.transferToken(address(borrowAsset), address(borrower), 1);
        borrower.setAllowance(address(pcl), address(borrowAsset), type(uint256).max);
        borrower.repay(requestId, 1);
    }

    // Test 14: An expired PCL cannot be liquidated if principal == 0
    function test_lendersCannotLiquidateIfPrincipalIsZero(bool _withdraw) public {
        (, uint256 _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal != 0, 'Principal == 0');

        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay entire debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt);

        (, _principal, , , ) = pcl.pooledCreditLineVariables(requestId);
        assertTrue(_principal == 0, 'Principal != 0');

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_exchangeRateChanges();

        // _lender0 tries to liquidate the PCL
        try _lender0.liquidate(requestId, _withdraw) {
            revert('Cannot liquidate an expired PCL with principal == 0');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L1');
        }
    }

    // Test 14.1: An expired PCL cannot be liquidated if collateral CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.2: An expired PCL cannot be liquidated if borrow CToken exchange rate increases steeply
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt - 10000);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.3: An expired PCL cannot be liquidated if borrow CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfBorrowCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(borrowCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'PCL:L3');
        }
    }

    // Test 14.4: An expired PCL cannot be liquidated if collateral CToken exchange rate decreases to zero
    function test_lendersCannotLiquidateIfCollateralCTokenExchangeRateDecreasesToZero() public {
        uint256 _currentDebt = borrower.calculateCurrentDebt(requestId);
        // Borrower decides to repay partial debt
        admin.transferToken(address(borrowAsset), address(borrower), _currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), _currentDebt);
        borrower.repay(requestId, _currentDebt / 2);

        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        helper_decreaseExchangeRateToZero(collateralCTokenAddress);

        try _lender0.liquidate(requestId, false) {
            revert('Cannot liquidate an expired PCL with CR >= ICR');
        } catch Error(string memory reason) {
            assertEq(reason, 'CY:GTFS1');
        }
    }

    // Test 14.5: An expired PCL can be liquidated if collateral CToken exchange rate increases very slowly
    function test_lendersCanLiquidateIfCollateralCTokenExchangeRateIncreasesVerySlowly() public {
        (uint256 _requestId, ) = goToActiveStage(10, request.borrowLimit);
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        uint256 _requiredCollateral = borrower.getRequiredCollateral(_requestId, request.borrowLimit);
        admin.transferToken(request.collateralAsset, address(borrower), _requiredCollateral);
        borrower.setAllowance(address(pcl), request.collateralAsset, _requiredCollateral);
        borrower.depositCollateral(_requestId, _requiredCollateral, false);

        uint256 borrowableAmount = borrower.calculateBorrowableAmount(_requestId);
        borrower.borrow(_requestId, borrowableAmount);

        vm.warp(block.timestamp + request.duration / 2);
        uint256 currentDebt = borrower.calculateCurrentDebt(_requestId);
        admin.transferToken(address(borrowAsset), address(borrower), currentDebt);
        borrower.setAllowance(address(pooledCreditLineAddress), address(borrowAsset), currentDebt / 2);
        borrower.repay(_requestId, currentDebt / 100);

        vm.warp(block.timestamp + 100 + request.duration / 2);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.EXPIRED, '!Expired');
        helper_increaseExchangeRateSlowly(collateralCTokenAddress);
        _lender0.liquidate(_requestId, false);
        assertTrue(pcl.getStatusAndUpdate(_requestId) == PooledCreditLineStatus.LIQUIDATED);
    }

    // Test 15: Lenders cannot withdraw liquidation from an expired pcl
    function test_lendersCannotWithdrawLiquidation() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawTokensAfterLiquidation(requestId) {
            revert('Cannot withdraw liquidation from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWLC1');
        }
    }

    // Test 16: Lenders cannot withdraw liquidity from an expired pcl
    function test_lendersCannotWithdrawLiquidity() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        helper_exchangeRateChanges();

        try _lender0.withdrawLiquidity(requestId) {
            revert('Cannot withdraw liquidity from an expired PCL');
        } catch Error(string memory reason) {
            assertEq(reason, 'LP:IWL3');
        }
    }

    // Test 17: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossibleEntireBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance);

        //Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, 0);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == 0);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance + lender3PoolTokenBalance));
    }

    // Test 17.1: Pool token transfers should be possible in an expired PCL
    function test_poolTokenTransfersShouldBePossiblePartialBalance() public {
        PCLUser lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser lender1 = PCLUser(lenders[1].lenderAddress);
        PCLUser lender2 = PCLUser(lenders[2].lenderAddress);
        PCLUser lender3 = PCLUser(lenders[3].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalance = lp.balanceOf(address(lender1), requestId);
        uint256 lender2PoolTokenBalance = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalance = lp.balanceOf(address(lender3), requestId);

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);
        assertGt(lender2PoolTokenBalance, 0);
        assertGt(lender3PoolTokenBalance, 0);

        // Lender0 transfers pool tokens to lender1
        lender0.transferLPTokens(address(lender1), requestId, lender0PoolTokenBalance / 2);

        // Checking the transfer took place or not
        uint256 lender0PoolTokenBalanceFinal = lp.balanceOf(address(lender0), requestId);
        uint256 lender1PoolTokenBalanceFinal = lp.balanceOf(address(lender1), requestId);

        assertEq(lender0PoolTokenBalanceFinal, lender0PoolTokenBalance - lender0PoolTokenBalance / 2);
        assertTrue(lender1PoolTokenBalanceFinal == (lender0PoolTokenBalance / 2 + lender1PoolTokenBalance));

        // Price fluctuations take place
        helper_exchangeRateChanges();

        // Lender2 transfers pool tokens to lender3
        lender2.transferLPTokens(address(lender3), requestId, lender2PoolTokenBalance / 4);

        uint256 lender2PoolTokenBalanceFinal = lp.balanceOf(address(lender2), requestId);
        uint256 lender3PoolTokenBalanceFinal = lp.balanceOf(address(lender3), requestId);

        // Checking whether the transfer took place or not
        assertTrue(lender2PoolTokenBalanceFinal == lender2PoolTokenBalance - lender2PoolTokenBalance / 4);
        assertTrue(lender3PoolTokenBalanceFinal == (lender2PoolTokenBalance / 4 + lender3PoolTokenBalance));
    }

    // Test 18: Interest can be withdrawn amidst exchange rate fluctuations
    function test_lendersCanWithdrawInterest() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);
        PCLUser _lender1 = PCLUser(lenders[1].lenderAddress);

        // Ensuring that these lenders indeed had lent something
        uint256 lender0PoolTokenBalance = lp.balanceOf(address(_lender0), requestId);
        uint256 lender0Balance = borrowAsset.balanceOf(address(_lender0));

        uint256 lender1PoolTokenBalance = lp.balanceOf(address(_lender1), requestId);
        uint256 lender1Balance = borrowAsset.balanceOf(address(_lender1));

        assertGt(lender0PoolTokenBalance, 0);
        assertGt(lender1PoolTokenBalance, 0);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        uint256 lender1InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender1));

        _lender0.withdrawInterest(requestId);

        uint256 lender0BalanceFinal = borrowAsset.balanceOf(address(_lender0));
        assertEq((lender0BalanceFinal - lender0Balance), lender0InterestOwed);

        helper_exchangeRateChanges();

        _lender1.withdrawInterest(requestId);

        uint256 lender1BalanceFinal = borrowAsset.balanceOf(address(_lender1));
        assertGt((lender1BalanceFinal - lender1Balance), lender1InterestOwed);
    }

    // Test 18.1: Interest that can be withdrawn increases
    function test_lenderInterestIncreasesIfBorrowCTokenExchangeRateIncreasesSteeply() public {
        PCLUser _lender0 = PCLUser(lenders[0].lenderAddress);

        // Fetching the interest owed to lenders
        uint256 lender0InterestOwed = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        helper_increaseExchangeRateSteeply(borrowCTokenAddress);

        uint256 lender0InterestOwedNew = lp.getLenderInterestWithdrawable(requestId, address(_lender0));
        assertLt(lender0InterestOwed, lender0InterestOwedNew);
    }

    uint256 _principal;
    uint256 _currentCR1;
    uint256 _currentCR2;
    uint256 _currentCR3;
    uint256 _principalWithdrawable;
    uint256 _withdrawableCollateral;
    uint256 _currentDebt;
    uint256 _borrowable;
    uint256 _totalCollateral;
    uint256 _equivalentCollateral;
    uint256 _interestAccrued;

    uint256 collateralToDeposit;

    function assert_helperFunctionalitiesInExpiredState(uint256 _id) public {
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);

        PCLUser _lender = PCLUser(lenders[0].lenderAddress);
        PCLUser _borrower = borrower;

        // 1. calculateCurrentCollateralRatio
        _currentCR1 = _borrower.calculateCurrentCollateralRatio(_id);
        assertLt(_currentCR2, uint256(-1));

        helper_exchangeRateChanges();

        // 2. calculatePrincipalWithdrawable
        _principalWithdrawable = _lender.calculatePrincipalWithdrawable(_id, address(_lender));
        assertEq(_principalWithdrawable, 0); // Since the lenders cannot withdraw their liquidity from an expired PCL

        helper_exchangeRateChanges();

        // 3. withdrawableCollateral
        _withdrawableCollateral = _borrower.withdrawableCollateral(_id);
        assertEq(_withdrawableCollateral, 0); // Since no collateral can be withdrawn in the expired state

        helper_exchangeRateChanges();

        // 4. calculateCurrentDebt
        _currentDebt = _borrower.calculateCurrentDebt(_id);
        assertGt(_currentDebt, 0);

        helper_exchangeRateChanges();

        // 5. calculateBorrowableAmount
        _borrowable = _borrower.calculateBorrowableAmount(_id);
        assertEq(_borrowable, 0); // Since the state is expired

        helper_exchangeRateChanges();

        // 6. calculateTotalCollateralTokens
        _totalCollateral = _borrower.calculateTotalCollateralTokens(_id);
        assertGt(_totalCollateral, 0);

        helper_exchangeRateChanges();

        // 7. collateralTokensToLiquidate
        _equivalentCollateral = _borrower.collateralTokensToLiquidate(_id, lp.totalSupply(_id));
        assertGt(_equivalentCollateral, 0);

        helper_exchangeRateChanges();

        // 8. calculateInterestAccrued
        _interestAccrued = _borrower.calculateInterestAccrued(_id);
        assertGt(_interestAccrued, 0);

        helper_exchangeRateChanges();
        assertTrue(pcl.getStatusAndUpdate(_id) == PooledCreditLineStatus.EXPIRED);
    }

    function test_helperFunctionalitiesInExpiredState() public {
        assert_helperFunctionalitiesInExpiredState(requestId);
    }
}
".

Existing Test Reports:

"The software run successfully without errors."

Based on the given test reports, please identify and succinctly summarize all bugs causing issues within the contract codes. The objective is to obtain a clear and consolidated overview of all identified bugs. Conclude with a comprehensive test report summarizing the findings.

